| generador de codigo para 386
| PHREDA 2017
|----------------------------------
^r4/compiler/r4-cellana.txt

#nstr
#nlabel
#strpending

#nroi
#regIO | dicc de IO 16 bytes

|-------- guarda registros
| in out used (16 bytes)
:rsetI	| ;entrada
|	4 <<
|	stki
|	c@+ ( 1? )( 1- swap c@+
	 ;

	c@+ 1- + c@ $ff and
	;
:rsetO	| ;salida
	;
:rsetU	| ;usados
	;


|-------- constantes del sistema
#syscons "XRES" "YRES" "FREE_MEM" "SYSFRAME" "XFB"
"SYSPAPER" "SYSXYM" "SYSBM" "SYSKEY" | []

#sysregs "eax" "ebx" "ecx" "edx" "edi" "esi" "ebp"
#sysregw "ax" "bx" "cx" "dx" "di" "si" "bp"
#sysregb "al" "bl" "cl" "dl" "*" "*" "*"

|------ Celda de la pila
| $0 nro
| $1 cte
| $2 str
| $3 cod
| $4 dat
| $5 reg
| $10 mem
| $20 *
| $40 +
|-------- tipos de celdas
#cellt )( 1024	| tipo
#cellv )( 1024	| valor
#cella )( 1024  | suma
#cells )( 1024  | shift

:value	over 2 << 'cellv + @ ;
:suma	over 2 << 'cella + @ ;
:shift	over 2 << 'cells + @ ;

:inicelreg
	2 <<
	5 over 'cellt + !
	swap over 'cellv + !
	0 over 'cella + !
	0 swap 'cells + !
	;

|---- imprime celda
:list2str swap ( 1? )( 1- swap >>0 swap ) drop ;

:mt0 value -? ( "(%d)" ,print ; ) "$%h" ,print ;	|--	0 nro 	33
:mt1 value 'syscons list2str ,s ;	|--	1 cte	XRES
:mt2 value "str%h" ,print ;			|--	2 str   "hola"
:mt3 value "w%h" ,print ;			|--	3 cod  'func		4 dat  'var
:mt5 value 'sysregs list2str ,s ;	|-- 8 reg 	eax

#tiposrm mt0 mt1 mt2 mt3 mt3 mt5 0 0 0

:,reg | nro --
	'sysregs list2str ,s ;

:,cell | nro --
	dup 2 << 'cellt + @
	$10 and? ( "dword [" ,s )
	dup $7 and 2 << 'tiposrm + @  exec
	$20 and? ( "*" ,s dup ,d )
	$40 and? ( +? ( "+" ,s ) dup ,d )
	$10 and? ( "]" ,s )
	drop ;

:mt5b value 'sysregb list2str ,s ;
#tiposrmb mt0 mt1 mt2 mt3 mt3 mt5b 0 0 0

:,cellb | nro --
	dup 2 << 'cellt + @
	$10 and? ( "byte [" ,s )
	dup $7 and 2 << 'tiposrmb + @  exec
	$20 and? ( "*" ,s dup ,d )
	$40 and? ( +? ( "+" ,s ) dup ,d )
	$10 and? ( "]" ,s )
	drop ;

:mt5w value 'sysregw list2str ,s ;
#tiposrmw mt0 mt1 mt2 mt3 mt3 mt5w 0 0 0

:,cellw | nro --
	dup 2 << 'cellt + @
	$10 and? ( "word [" ,s )
	dup $7 and 2 << 'tiposrmw + @  exec
	$20 and? ( "*" ,s dup ,d )
	$40 and? ( +? ( "+" ,s ) dup ,d )
	$10 and? ( "]" ,s )
	drop ;


:,cell2REG | cell reg --
|	over cell0? 1? ( drop nip "xor " ,s dup ,REG "," ,s ,REG ,cr ; ) drop
	"mov " ,s ,REG "," ,s ,CELL ,cr ;

:dumpcel
	0 ( cntvreg 1- <? )(
		dup ,d ,sp ,cell ,cr
		1+ ) drop ;

|------ acceso a celdas
:stknow	nroi 2 << 'stki + @ ;
:stknex nroi 1+ 2 << 'stki + @ ;

:stktos c@+ 1- + c@ $ff and ;
:stknos c@+ 2 - + c@ $ff and ;
:stknos2 c@+ 3 - + c@ $ff and ;
:stknos3 c@+ 4 - + c@ $ff and ;
:stknos4 c@+ 5 - + c@ $ff and ;

:stkrtos c@+ + c@+ + c@ $ff and ;

|--- token a cte
:c7 tok>cte "$%h"  ;
:cB 8 >> "str%h" ;
:cC 8 >> "w%h" ;

#codeisa 0 0 0 0 0 0 0 c7 c7 c7 c7 cB cC cC cC cC

:tokencte | a -- mem
	dup $ff and 2 << 'codeisa + @ 0? ( trace 2drop ; ) exec ;

:registro
	cellreg
	1- ,cell | registro virtual
	drop ;

:emitcell | cell --
	dup cellreg? 1? ( drop registro ; ) drop
	celltok
	256 <? ( registro ; ) |,sp "copia" ,s ,d ; ) | copia
	@ tokencte ,print
	;

:cellvalue? | cell -- token/0
	celltok
	256 <? ( ; ) | copia
	@ dup $ff and
	7 10 between 1? ( drop ; )
	2drop 0 ;

:,TOS	stknow stktos emitcell ;
:,TOSb	stknow stktos emitcell ;

:,NOS	stknow stknos emitcell ;
:,NOSb	stknow stknos emitcell ;
:,NOSw	stknow stknos emitcell ;

:,PK2	stknow stknos2 emitcell ;
:,PK3	stknow stknos3 emitcell ;
:,PK4	stknow stknos4 emitcell ;

:,RTOS	stknow stkrtos emitcell ;

:>TOSreg?	stknex stktos cellreg? ;
:,>TOS		stknex stktos emitcell ;
:>NOSreg?	stknex stknos cellreg? ;
:,>NOS		stknex stknos emitcell ;

|------------
:buildstack
	stknow
	c@+ ( 1? )( 1-
		swap c@+ ,sp ,d
		swap ) 2drop
	,cr
	;

|------------ compila CODIGO
|:nro>dicn2   8 >> 5 << 'indicepal + @ ; | nombre
:nro>dicn   8 >> "w%h" mprint ;			| numero de palabra
:toknow		dup 4 - @ ;

:,defw
    dup 4 - @ 8 >> "w%h:" ,print ;

:,defv ; | no hay definiciones en optimizado
:,[ :,] ; | no hay anonimas en optimizado

:vpila2v
	drop ;

:,wor
	dup @ $ff and 			| word ;
	16 =? ( "jmp " )( "call " ) nip ,s
	toknow nro>dicn ,s ,cr

|	toknow 8 >> vpila2callV
|	strpending neg
|	1? ( "; strpending:" ,s dup ,d ,cr )
|	pila2v
	0 'strpending !
	;

:,callsys | usapila? --
|	1? ( vpila2normal )
	drop
	dup @ $ff and | word ;
	16 =? ( "jmp " )( "call " ) nip
	,s ;

:,END		"jmp SYSEND" ,ln ;
:,FFIRST 	1 ,callsys "SYSFFIRST" ,ln ;
:,FNEXT		1 ,callsys "SYSFNEXT" ,ln 1 vpila2v ;
:,LOAD		1 ,callsys "SYSLOAD" ,ln -1 vpila2v ;
:,SAVE		1 ,callsys "SYSSAVE" ,ln -3 vpila2v ;
:,APPEND	1 ,callsys "SYSAPPEND" ,ln -3 vpila2v ;
:,UPDATE	1 ,callsys "SYSUPDATE" ,ln ;
:,MSEC		1 ,callsys "SYSMSEC" ,ln 1 vpila2v ;
:,TIME		1 ,callsys "SYSTIME" ,ln 3 vpila2v ;
:,DATE		1 ,callsys "SYSDATE" ,ln 3 vpila2v ;
:,RUN		1 ,callsys "SYSRUN" ,ln ;
:,CLS		0 ,callsys "SYSCLS" ,ln ;
:,REDRAW	0 ,callsys "SYSREDRAW" ,ln ;
:,>XFB  	0 ,callsys "SYSTOXFB" ,ln ;
:,XFB>  	0 ,callsys "SYSXFBTO" ,ln ;
:,SYSTEM	1 ,callsys "SYSYSTEM" ,ln ; | "sys" -- ret

:,;
	dup 8 - @ $ff and | word ;
	12 =? ( drop ; ) drop
	buildstack
	"ret" ,ln ;

:,lit
    >TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS "," ,s ,TOS ,cr
	;
:,lits
	toknow tok>mem strusestack
	'strpending ! drop
	1 'nstr +!
	>TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS "," ,s ,TOS ,cr
	;
:,dwo
    >TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS "," ,s ,TOS ,cr
	;
:,dva
    >TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS "," ,s ,TOS ,cr
	;
:,var
    >TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS ",[" ,s ,TOS "]" ,s ,cr
	;

|-------- CONDICIONALES
#jmpstr 0

:,simple?
	'jmpstr !
|	d.cnt 0? ( vpila2normal ) drop
|	d.tos needWrite
|	d.tos cellADR? 1? ( drop
|		"cmp " ,s ,TOS ",0" ,ln ; ) drop
	"or " ,s ,TOS "," ,s ,TOS ,cr
	;

:,0? "jnz " ,simple? ;
:,+? "js "  ,simple? ;
:,-? "jns " ,simple? ;
:,1? "jz "  ,simple? ;

:,doble?
	'jmpstr !
|	d.nos needWrite
|	d.tos cellADR? 1? ( drop
|		d.nos cellADR? 1? ( drop
|			newReg 6 >? ( drop freelastreg newReg )
|			"mov " ,s dup ,REG "," ,s ,TOS ,cr
|			"cmp " ,s ,NOS "," ,s ,REG ,cr
|			d.drop ;
|			)( drop ) )( drop )
    "cmp " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;

:,=? "jnz " ,doble?	;
:,<? "jge " ,doble?	;
:,>? "jle " ,doble?	;
:,<=? "jg " ,doble?	;
:,>=? "jl " ,doble?	;
:,<>? "jz " ,doble?	;

:,bit?
	'jmpstr !
|	d.nos needWrite
|	d.tos cellADR? 1? ( drop
|		d.nos cellADR? 1? ( drop
|			newReg 6 >? ( drop freelastreg newReg )
|			"mov " ,s dup ,REG "," ,s ,TOS ,cr
|			"test " ,s ,NOS "," ,s ,REG ,cr
|			 ;
|			) )( drop )
    "test " ,s ,NOS "," ,s ,TOS ,cr
	d.drop ;

:,and?  "jz " ,bit?	;
:,nand? "jnz " ,bit? ;

|----- auxiliares bloques
:label		"_" ,s ,h ;
:jmp,		"jmp " ,s label ,cr ;
:,etiqueta	label ": " ,s ;
:,jmpcond   jmpstr ,s label ,cr ;

:+etiqueta	| -- nueva   // y agrega a pila
	nlabel 1+ dup 'nlabel ! dup c.push ;

|----- BLOQUES
#nblock 0

:block.new
	nblock pilab> !+ 'pilab> !
	1 'nblock +! ;
:block.end
	-4 'pilab> +! ;
:block.now
	pilab> |'pilab =? ( drop 0 ; )
	4 - @ ; | -- nblo

| 0 ( )		REP
| 1 ?( )	IF
| 2 ( ?)( ) WHI
| 3 ?( )( )	IFE
| 4 ( ?)	UNT
| or $8 ;
:block.type | -- type
	block.now 2 << 'blocki + @ ;

:,(
	block.new
	block.type
	%1 and? ( +etiqueta ,jmpcond	| IF ELSE
		)( +etiqueta ,etiqueta )
	drop
	;

:,)(
	block.type
	%1 and? ( c.pop +etiqueta jmp, ,etiqueta	| ELSE
		)( c.pop +etiqueta ,jmpcond c.push )	| WHILE
	drop
	;

:,)
	block.type 7 and	| FALTA ;)
	0? ( c.pop jmp, )					| REP
	1 =? ( c.pop ,etiqueta )			| IF
	2 =? ( c.pop jmp, c.pop ,etiqueta )	| WHILE
	3 =? ( c.pop ,etiqueta )			| ELSE
	4 =? ( c.pop ,jmpcond )				| UNTIL
	drop
	block.end ;

|------- EXEC
:,execr
	dup @ $ff and 			| word ;
	16 =? ( "jmp ecx" )( "call ecx" ) nip
	,s ,cr
	;

:,EXECPP | v --
	"push " ,s d.tos ,CELL ,cr
	dup @ $ff and 			| word ;
	12 <>? ( "pop ecx" ,ln "call ecx" ,s ,cr ) drop		| en pila y ret.. listo!
	;

:,EXEC | v --
|	d.tos cellVAR -? ( 2drop ,EXECPP ; ) 2drop
	"mov ecx," ,s ,TOS ,cr
	,execr ;

|------- PILAD
:,dup
    >TOSreg? 0? ( drop ; ) drop

    "mov " ,s ,>TOS "," ,s ,TOS ,cr
	;
:,over
    >TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS "," ,s ,NOS ,cr
	;
:,pick2
    >TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS "," ,s ,PK2 ,cr
	;
:,pick3
    >TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS "," ,s ,PK3 ,cr
	;
:,pick4
    >TOSreg? 0? ( drop ; ) drop
    "mov " ,s ,>TOS "," ,s ,PK4 ,cr
	;
:,2dup
	>TOSreg? 1? ( "mov " ,s ,>TOS "," ,s ,TOS ,cr ) drop
	>NOSreg? 0? ( drop ; ) drop
	"mov " ,s ,>NOS "," ,s ,NOS ,cr
	;
:,2over
	>TOSreg? 1? ( "mov " ,s ,>TOS "," ,s ,PK2 ,cr ) drop
	>NOSreg? 0? ( drop ; ) drop
	"mov " ,s ,>NOS "," ,s ,PK3 ,cr
	;

|------- PILAR
:,>R
|	toknow 8 >> 1? ( drop d.pop r.push ; ) drop
|	"push " ,s ,TOS ,cr d.drop ;

:,R>
|	toknow 8 >> 1? ( drop r.pop d.push ; ) drop
|	d.dup d.tos needReg "pop " ,s ,TOS ,cr
;

:,R
|	toknow 8 >> 1? ( drop r.tos d.push ; ) drop
|	d.dup d.tos needReg "mov " ,s ,TOS ",dword [esp]" ,ln
;

:,RDROP
|	toknow 8 >> 1? ( drop r.drop ; ) drop
|	"lea esp,[esp+4]" ,ln
	;

:,R+
	"add " ,s ,RTOS "," ,s ,TOS ,cr
	;

:,R!+
	"mov dword [" ,s ,RTOS "]," ,s ,TOS ,cr
	"add " ,s ,RTOS ",4" ,ln
|	4 r.tos Cell+ | add 4
	;

:,R@+
	"mov " ,s ,TOS ",dword [" ,s ,RTOS "]" ,ln
	"add " ,s ,RTOS ",4" ,ln
|	4 r.tos Cell+ | add 4
	;

|----------------------
:,AND
	"and " ,s ,NOS "," ,s ,TOS ,cr
	;
:,OR
	"or " ,s ,NOS "," ,s ,TOS ,cr
	;
:,XOR
	"xor " ,s ,NOS "," ,s ,TOS ,cr
	;
:,+
	"add " ,s ,NOS "," ,s ,TOS ,cr
	;
:,-
	"sub " ,s ,NOS "," ,s ,TOS ,cr
	;
:,*
	| si d.tos es pow2..
	"imul " ,s ,NOS "," ,s ,TOS ,cr
	;
:,/
	| si d.tos es pow2..
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
|	freeEDX
 ;
:,/MOD
	| si d.tos es pow2..
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
|	d.nos setEAX
|	d.tos setEDX
;

:,MOD
	| si d.tos es pow2..
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
|	d.tos setEDX
|	freeEAX
;

:,*/
	"cdq" ,ln
	"imul " ,s ,NOS ,cr
	"idiv " ,s ,TOS ,cr
|	d.tos setEAX
|	freeEDX
;

:,*>>
	| si d.nos es pow2..
|	d.pk2 needEAX
|	usoEDX
|	d.nos needREGorMEM
|	d.tos cteorECX
	"cdq" ,ln
	"imul " ,s ,NOS ,cr
	"shrd eax,edx," ,s ,TOSb ,cr
|	"shr edx," ,s ,TOSb ,cr | no hace falta!!
|	freeEDX
	;

:,<</
|	d.pk2 needEAX
|	usoEDX
|	d.nos needREGorMEM
|	d.tos cteorECX
	"cdq" ,ln
    "shld edx,eax," ,s ,TOSb ,cr
	"shl eax," ,s ,TOSb ,cr
	"idiv " ,s ,NOS ,cr
|	d.tos setEAX
|	freeEDX
	;

:,<<
|	d.tos cteorECX
|	d.nos needWrite
	"sal " ,s ,NOS "," ,s ,TOSb ,cr
;

:,>>
|	d.tos cteorECX
|	d.nos needWrite
	"sar " ,s ,NOS "," ,s ,TOSb ,cr
	;

:,ABS
|	usoEDX
|	d.tos needWrite
|	d.tos cellREG? 0? ( | EAX
|		"cdq" ,ln
|		)(
		"mov edx," ,s ,TOS ,cr
		"sar edx,31" ,ln
|		) drop
	"add " ,s ,TOS ",edx" ,ln
	"xor " ,s ,TOS ",edx" ,ln
|	freeEDX
	;

:,CLZ
|	d.tos needWrite
	"bsr " ,s ,TOS  "," ,s ,TOS ,cr
	"xor " ,s ,TOS ",31" ,ln ;
:,NOT
|	d.tos needWrite
	"not " ,s ,TOS ,cr ;
:,NEG
|	d.tos needWrite
	"neg " ,s ,TOS ,cr ;
:,1+
|	d.tos needWrite
	"add " ,s ,TOS ",1" ,ln ;
:,4+
|	d.tos needWrite
	"add " ,s ,TOS ",4" ,ln ;
:,1-
|	d.tos needWrite
	"sub " ,s ,TOS ",1" ,ln ;
:,2/
|	d.tos needWrite
	"sar " ,s ,TOS ",1" ,ln ;
:,2*
|	d.tos needWrite
	"sal " ,s ,TOS ",1" ,ln ;

    |------ MEMORIA
:,@
|	d.tos needWrite
	"mov " ,s ,TOS ",dword [" ,s ,TOS "]" ,ln ;
:,C@
|	d.tos needWrite
	"movsx " ,s ,TOS ",byte [" ,s ,TOS "]" ,ln ;
:,W@
|	d.tos needWrite
	"movsx " ,s ,TOS ",word [" ,s ,TOS "]" ,ln ;

:,!
|	d.tos resguardavar
|	d.tos needReadM
|	d.nos needReadM
	"mov dword [" ,s ,TOS "]," ,s ,NOS ,cr
	;
:,C!
|	d.tos resguardavar
|	d.tos needReadM
|	d.nos needReadB
	"mov byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	;
:,W!
|	d.tos resguardavar
|	d.tos needReadM
|	d.nos needReadW
	"mov word [" ,s ,TOS "]," ,s ,NOSw ,cr
	;

:,+!
|	d.tos resguardavar
|	d.nos needReadM
|	d.tos needReadM
	"add dword [" ,s ,TOS "]," ,s ,NOS ,cr
	;
:,W+!
|	d.tos resguardavar
|	d.nos needReadM
|	d.tos needReadM
	"add word [" ,s ,TOS "]," ,s ,NOSw ,cr
	;
:,C+!
|	d.tos resguardavar
|	d.nos needReadM
|	d.tos needReadM
	"add byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	;

:,!+
|	d.tos resguardavar
|    d.nos needReadM
|	d.tos needWrite
	"mov dword [" ,s ,TOS "]," ,s ,NOS ,cr
	"add " ,s ,TOS ",4" ,ln
	;
:,W!+
|	d.tos resguardavar
|    d.nos needReadM
|	d.tos needWrite
	"mov word [" ,s ,TOS "]," ,s ,NOSw ,cr
	"add " ,s ,TOS ",2" ,ln
;
:,C!+
|	d.tos resguardavar
|    d.nos needReadM
|	d.tos needWrite
	"mov byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	"add " ,s ,TOS ",1" ,ln
	;

:,@+
|	d.tos needWrite
|	d.dup d.tos needReg
	"mov " ,s ,TOS ",dword [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",4" ,ln ;
:,W@+
|	d.tos needWrite
|	d.dup d.tos needReg
	"movsx " ,s ,TOS ",word [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",2" ,ln ;
:,C@+
|	d.tos needWrite
|	d.dup d.tos needReg
	"movsx " ,s ,TOS ",byte [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",1" ,ln ;

|--------- Sistema
|#syscons "XRES" "YRES" "FREE_MEM" "SYSFRAME" "XFB" | [] | "SYSPAPER" "SYSXYM" "SYSBM" "SYSKEY"

:,SW 		|0 pushCTE |fullscreen 1? ( d.tos cellMEM! ) drop
;
:,SH		|1 pushCTE |fullscreen 1? ( d.tos cellMEM! ) drop
;
:,MEM		|2 pushCTE |d.tos cellMEM!
;
:,FRAMEV	|3 pushCTE
;
:,XFB		|4 pushCTE
;

:,BMOUSE | -- c
	|7 pushCTE d.tos cellMEM!
	;

:,KEY	| -- c
	|8 pushCTE d.tos cellMEM!
	;

:,PAPER | n --
|	d.tos needReadM | no memoria []
	"mov [SYSPAPER]," ,s ,TOS ,cr
 ;

:,KEY! | v --
|	d.tos needReadM | no memoria []
	"mov [SYSKEY]," ,s ,TOS ,cr
;

:,SETXYf | x y --
|	d.tos cellNRO? 1? ( drop
|		d.nos cellNRO? 1? ( drop
|			"lea ebp,[SYSFRAME+(" ,s ,TOS "*XRES+" ,s ,NOS ")*4]" ,ln
|			; ) drop ) drop

|	d.tos needWrite
|	"imul " ,s ,TOS ",XRES" ,ln	| cualquier ancho
	"shl " ,s ,TOS ",10" ,ln	| 1024 de ancho
|	d.nos cell0? 0? ( "add " ,s ,TOS "," ,s ,NOS ,cr ) drop
	"lea ebp,[SYSFRAME+" ,s ,TOS "*4]" ,ln
;

:,SETXY | x y --
|	fullscreen 0? ( drop ,SETXYf ; ) drop
|	d.tos needWrite
	"imul " ,s ,TOS ",[XRES]" ,ln	| cualquier ancho
|	d.nos cell0? 0? ( "add " ,s ,TOS "," ,s ,NOS ,cr ) drop
	"lea ebp,[SYSFRAME+" ,s ,TOS "*4]" ,ln
;

:,PX+!	| s --
|	d.tos needReadM
	"lea ebp,[ebp+" ,s ,TOS "*4]" ,ln
;

:,PX!+	| rgb --
|	d.tos needReadM
	"mov dword [ebp]," ,s ,TOS ,cr
	"add ebp,4" ,ln
;

:,PX@	| -- rgb
|	d.dup d.tos needREG
	"mov " ,s ,>TOS ",dword [ebp]" ,ln ;

:,XYMOUSE | -- x y
|	d.dup d.tos needREG
|	d.dup d.tos needREG
	"mov " ,s ,TOS ",[SYSXYM]" ,ln
	"mov " ,s ,NOS "," ,s ,TOS ,cr
	"and " ,s ,NOS ",$ffff" ,ln
	"shr " ,s ,TOS ",16" ,ln
	;

:,CNTJOY
|	"xor eax,eax" ,ln
;
:,GETJOY
:,SLOAD
:,SPLAY
:,SINFO
:,SSET  ;

:,DOCINI
:,DOCEND
:,OPENURL	| url header buff -- buff/0
:,DOCAT     | x y --
:,DOCLINE	| x y --
:,DOCTEXT	| "tt" --
:,DOCFONT	| size angle "font" --
:,DOCBIT	| bitmap x y --
:,DOCRES	| -- xmax ymax
:,DOCSIZE	| "tt" -- w h
	;

|----------- en asmbase.txt
:,SQRT
:,MOVE :,MOVE> :,CMOVE :,CMOVE>
:,INK :,INK@ :,ALPHA
:,OP :,LINE :,CURVE :,CURVE3 :,PLINE :,PCURVE :,PCURVE3 :,POLI
:,FCOL :,FCEN :,FMAT :,SFILL :,LFILL :,RFILL :,TFILL ;

#acompila 0
,defw ,defw ,defv ,defv 0 0
,lit ,lit ,lit ,lit ,lits
,wor ,var ,dwo ,dva
,; ,( ,)( ,) ,[ ,] ,EXEC
,0? ,+? ,-? ,1? ,=? ,<? ,>? ,<=? ,>=? ,<>? ,AND? ,NAND? | 30

,dup 0 ,over ,pick2 ,pick3 ,pick4 0 0
0 ,2dup 0 0 0 ,2over 0

,>R ,R> ,R ,R+ ,R@+ ,R!+ ,RDROP					|--- pila direcciones 52
,AND ,OR ,XOR ,NOT  								|--- logicas        56
,+ ,- ,* ,/ ,*/ ,*>> ,/MOD ,MOD ,ABS  			|--- aritmeticas | 65
,SQRT ,CLZ ,<</ ,NEG ,1+ ,4+ ,1- ,2/ ,2* ,<< ,>> | 76
,@ ,C@ ,W@ ,! ,C! ,W! ,+! ,C+! ,W+!  			|--- memoria 85
,@+ ,!+ ,C@+ ,C!+ ,W@+ ,W!+	| 91
,MOVE ,MOVE> ,CMOVE ,CMOVE> | 95
,MEM ,FFIRST ,FNEXT
,LOAD ,SAVE ,APPEND		|--- memoria bloques 102
,UPDATE
,XYMOUSE ,BMOUSE
,KEY! ,KEY
,CNTJOY ,GETJOY 							| 109
,MSEC ,TIME ,DATE ,END ,RUN 				|--- sistema 114
,SW ,SH ,CLS ,REDRAW ,FRAMEV  						|--- pantalla
,SETXY ,PX+! ,PX!+ ,PX@
,XFB ,>XFB ,XFB>
,PAPER ,INK ,INK@ ,ALPHA							|--- color
,OP ,LINE ,CURVE ,CURVE3 ,PLINE ,PCURVE ,PCURVE3 ,POLI		|--- dibujo
,FCOL ,FCEN ,FMAT ,SFILL ,LFILL ,RFILL ,TFILL
,SLOAD ,SPLAY ,SINFO ,SSET					|--- Sonido
,OPENURL
,DOCINI ,DOCEND ,DOCAT ,DOCLINE ,DOCTEXT ,DOCFONT ,DOCBIT ,DOCRES ,DOCSIZE  |-- impresora
,SYSTEM

:,cadatoken | adr+ t -- adr+
	$ff and 2 << 'acompila + @ 0? ( drop ; )
	exec ;

:iniciaregistros
	0 ( cntvreg 1- <? )(
		dup dup inicelreg
		1+ ) drop
|	dumpcel

	,cr
	stki c@+
	( 1? )( 1- swap c@+
		,cell " %d " ,print
		swap ) 2drop
	,cr

	;

:codeini | w -- w
	'pilac 'pilac> !
	'pilab 'pilab> !
	0 'nblock !
	0 'strpending !
	0 'nroi !
	;

::,code | w --
	iniciaregistros

	codeini
	dup dic>tok @ swap dic>len@
	( 1? )( 1- swap @+
		9 ,c "; " ,s dup tokenstr ,print
		9 ,c nroi ,stackm ,cr

		,cadatoken swap

|		"r4/compiler/code.asm" savemem | DEBUG
		1 'nroi +!
		) 2drop ;

::inicodegen
	here dup 'regIO !
	cntwords 4 <<	| 16 bytes por word
	+ 'here ! ;
