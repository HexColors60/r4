| generador de codigo para 386
| PHREDA 2017
|----------------------------------
^r4/compiler/r4-cellana.txt
^r4/compiler/r4-regx86.txt

#nword		| nro palabra
#nlabel		| nro label
#nstr		| nro string
#strpending	| for str stack
#nroi		| nro token
#regIO 		| dicc de IO 16 bytes

|------ acceso a celdas
:stknow	nroi 2 << 'stki + @ ;
:stknex nroi 1+ 2 << 'stki + @ ;

:stktos c@+ 1- + c@ $ff and ;
:stknos c@+ 2 - + c@ $ff and ;
:stkpk2 c@+ 3 - + c@ $ff and ;
:stkpk3 c@+ 4 - + c@ $ff and ;
:stkpk4 c@+ 5 - + c@ $ff and ;

:stkrtos c@+ + c@+ + 1- c@ $ff and ;

:value	nroi 2 << tokenini + @ tok>cte ;
:strm	nroi 2 << tokenini + @ tok>mem ;

:>DTOS	stknex stktos ;
:>DNOS	stknex stknos ;

:DTOS	stknow stktos ;
:DNOS	stknow stknos ;
:DPK2	stknow stkpk2 ;
:DPK3	stknow stkpk3 ;
:DPK4	stknow stkpk4 ;

:RTOS	stknow stkrtos ;

|-----------
:,VALUE	value "$%h" ,print ;
:,STRM	strm "str%h" ,print ;

:,TOS	stknow stktos ,cell drop ;
:,TOSb	stknow stktos ,cellb drop ;
:,TOSw	stknow stktos ,cellw drop ;

:,NOS	stknow stknos ,cell drop ;
:,NOSb	stknow stknos ,cellb drop ;
:,NOSw	stknow stknos ,cellw drop ;

:,PK2	stknow stkpk2 ,cell drop ;
:,PK3	stknow stkpk3 ,cell drop ;
:,PK4	stknow stkpk4 ,cell drop ;

:,RTOS	stknow stkrtos ,cell drop ;

:>TOSreg?	stknex stktos cellreg? ;
:,>TOS		stknex stktos ,cell drop ;
:>NOSreg?	stknex stknos cellreg? ;
:,>NOS		stknex stknos ,cell drop ;

:regused
	emptyReg
	stknow
	c@+ ( 1? )( 1-
		swap c@+ fillReg
		swap ) 2drop ;

|------------
| tipo de celda que necesito
:cellEAX
	drop
	;
:cellECXCTE | cell --
|	cellreg? 2 =? ( 2drop ; )
	drop
	;

:cellREG
:cellREGMEM
	;
:usoEDX
	;
:setEAX		0 swap cell.reg! ;
:setEDX		3 swap cell.reg! ;


|-----------------
|:needreg | nro --
|	dup cellflag
|	$4 and? ( drop ; )	| entrada palabra
|	$8 and? ( drop ; )	| salida palabra
|	$1000 and? ( drop ; )	| eax
|	$2000 and? ( drop ; )	| ecx
|	drop ;

:marknoc | cell -- cell
	dup clivei 2 << 'stki + @
	c@+ ( 1? )( 1-
		swap c@+ cellfl dup @ $4000 or swap ! | mark no C
		swap ) 2drop ;

:cellstart
	dup cell.ini
	cellflag
	$ff0000 nand? ( drop ; )	| cte?
	$2000 nand? ( drop ; )		| need ecx?
	drop
	marknoc | ecx->marca no
	;

:cellin | ncel flag -- ncel flag
|	$1000 and? ( ) | eax
|	$4000 and? ( ) | no ecx
|	$2000 and? ( ) | ecx
	newReg
	dup reg!
	pick2 cell.reg! ;

:inputcells | w --
	emptyReg

	| init cells -1 (no asignada)
	0 ( ncell <? )( dup cellstart 1+ ) drop
	0 ( ncell <? )(
		dup cellflag $1 and? ( cellin ) drop
		1+ ) drop

	| save inputcells

   	nword 4 << regIO + >a
	stknow c@+
	dup a> c!+ >a
	"; IN: " ,s
	( 1? )( 1-
		swap c@+
		,cell ,sp
		a> c!+ >a	| **guardar el registro real!!
		swap ) 2drop
	-1 a> c! | marca sin final por ahora
	,cr
	;

:multientry
	;

:outputadjust | adr
	1+ >a | salto cantidad
	stknow c@+
	"; ADJ: " ,ln
	( 1? )( 1-
		swap c@+
		a> c@+ swap >a
		swap cellresolve
		swap ) 2drop ;

:outputcells
	nword 4 << regIO +
	c@+ +
	dup c@ +? ( drop outputadjust ; ) | ya marcado ajustar
	drop >a
	stknow c@+
	dup a> c!+ >a
	"; OUT: " ,s
	( 1? )( 1-
		swap c@+
		,cell ,sp
		a> c!+ >a | **guardar el registro real!!
		swap ) 2drop
	,cr
	;


:cellplain
	"; --- plain stack ---" ,ln
	stknow
	c@+ ( 1? )( 1-
		swap c@+ cellflat
		swap ) 2drop
	;

|------------ compila CODIGO
:nro>dicn   8 >> "w%h" mprint ;			| numero de palabra
:toknow		dup 4 - @ ;

:dumpinfoword
	"; " ,s	dup dic>str @ "%w" ,print
	" | " ,s dup dic>mov @ ,printmovword
	" | " ,s dup dic>inf @ ,printinfowor
	" | len:" ,s dup dic>len@ ,d
	" | calls:" ,s dup dic>call@ ,d
	,cr
	;

:,defw
	multientry
    dup 4 - @ 8 >> dumpinfoword "w" ,s ,h ":" ,s ,cr ;

:,defv ; | no hay definiciones en optimizado
:,[ :,] ; | no hay anonimas en optimizado

:vpila2v
	drop ;

:,wor
	dup @ $ff and 			| word ;
	16 =? ( "jmp " )( "call " ) nip ,s
	toknow nro>dicn ,s

|	toknow 8 >> vpila2callV
|	strpending neg
|	1? ( "; strpending:" ,s dup ,d ,cr )
|	pila2v
	0 'strpending !

	toknow tok>name " ; %w" ,print ,cr
	,cr ;

:,;
	dup 8 - @ $ff and | word ;
	16 =? ( drop ; ) drop
	outputcells
	"ret" ,ln ;

|--

:eligeReg
	regused
	>DTOS cellflag $4000 and? ( 2 reg! ) drop  | ECX
    newreg >DTOS cell.reg! ;

	

|---------- ASIGNACIONES
:,lit
    >TOSreg? 0? ( drop VALUE >DTOS cell.Val! ; ) drop
	eligeReg
	"mov " ,s ,>TOS "," ,s ,VALUE ,cr
	;

:,lits
	toknow tok>mem strusestack
	'strpending ! drop
	1 'nstr +!
	>TOSreg? 0? ( drop STRM >DTOS cell.Str! ; ) drop
	eligeReg
    "mov " ,s ,>TOS "," ,s ,STRM ,cr
	;
:,dwo
    >TOSreg? 0? ( drop VALUE >DTOS cell.wor! ; ) drop
    eligeReg
    "mov " ,s ,>TOS "," ,s ,VALUE ,cr
	;
:,dva
    >TOSreg? 0? ( drop VALUE >DTOS cell.wor! ; ) drop
    eligeReg
    "mov " ,s ,>TOS "," ,s ,VALUE ,cr
	;
:,var
    >TOSreg? 0? ( drop VALUE >DTOS cell.wor! >DTOS cell.mem ; ) drop
    eligeReg
    "mov " ,s ,>TOS ",[" ,s ,VALUE "]" ,s ,cr
	;


|-------- CONDICIONALES
#jmpstr 0

:simple
	cellplain
|	d.cnt 0? ( vpila2normal ) drop
|	d.tos needWrite
|	d.tos cellADR? 1? ( drop
|		"cmp " ,s ,TOS ",0" ,ln ; ) drop
	"or " ,s ,TOS "," ,s ,TOS ,cr
	;

:doble
|	d.nos needWrite

|	d.tos cellADR? 1? ( drop
|		d.nos cellADR? 1? ( drop
|			newReg 6 >? ( drop freelastreg newReg )
|			"mov " ,s dup ,REG "," ,s ,TOS ,cr
|			"cmp " ,s ,NOS "," ,s ,REG ,cr
|			d.drop ;
|			)( drop ) )( drop )
    "cmp " ,s ,NOS "," ,s ,TOS ,cr
	;

:bit
|	d.nos needWrite
|	d.tos cellADR? 1? ( drop
|		d.nos cellADR? 1? ( drop
|			newReg 6 >? ( drop freelastreg newReg )
|			"mov " ,s dup ,REG "," ,s ,TOS ,cr
|			"test " ,s ,NOS "," ,s ,REG ,cr
|			 ;
|			) )( drop )
    "test " ,s ,NOS "," ,s ,TOS ,cr
	;

#jmpmode 'simple

:,simple?	'jmpstr ! 'simple 'jmpmode ! ;

:,0? "jnz " ,simple? ;
:,+? "js "  ,simple? ;
:,-? "jns " ,simple? ;
:,1? "jz "  ,simple? ;

:,doble?	'jmpstr ! 'doble 'jmpmode ! ;

:,=? "jnz " ,doble?	;
:,<? "jge " ,doble?	;
:,>? "jle " ,doble?	;
:,<=? "jg " ,doble?	;
:,>=? "jl " ,doble?	;
:,<>? "jz " ,doble?	;

:,bit?	'jmpstr ! 'bit 'jmpmode ! ;

:,and?  "jz " ,bit?	;
:,nand? "jnz " ,bit? ;

|----- auxiliares bloques
:label		"_" ,s ,h ;
:jmp,		"jmp " ,s label ,cr ;
:,etiqueta	label ": " ,s ;
:,jmpcond
	jmpmode exec
	jmpstr ,s label ,cr ;

:+etiqueta	| -- nueva   // y agrega a pila
	nlabel 1+ dup 'nlabel ! dup c.push ;

|----- BLOQUES
#nblock 0

:block.new
	nblock pilab> !+ 'pilab> !
	1 'nblock +! ;
:block.end
	-4 'pilab> +! ;
:block.now
	pilab> |'pilab =? ( drop 0 ; )
	4 - @ ; | -- nblo

| 0 ( )		REP
| 1 ?( )	IF
| 2 ( ?)( ) WHI
| 3 ?( )( )	IFE
| 4 ( ?)	UNT
| or $8 ;
:block.type | -- type
	block.now 2 << 'blocki + @ ;

:,(
	block.new
	block.type
	%1 and? ( +etiqueta ,jmpcond	| IF ELSE
		)(  +etiqueta ,etiqueta )
	drop
	;

:,)(
	block.type
	%1 and? ( c.pop +etiqueta jmp, ,etiqueta	| ELSE
		)( c.pop +etiqueta ,jmpcond c.push )	| WHILE
	drop
	;

:,)
	block.type 7 and	| FALTA ;)
	0? ( c.pop jmp, )					| REP
	1 =? ( c.pop ,etiqueta )			| IF
	2 =? ( c.pop jmp, c.pop ,etiqueta )	| WHILE
	3 =? ( c.pop ,etiqueta )			| ELSE
	4 =? ( c.pop ,jmpcond )				| UNTIL
	drop
	block.end ;

|------------------------------ pila
:,dup
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
    "mov " ,s ,>TOS "," ,s ,TOS ,cr
	;
:,over
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
	"mov " ,s ,>TOS "," ,s ,NOS ,cr
	;
:,pick2
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
    "mov " ,s ,>TOS "," ,s ,PK2 ,cr
	;
:,pick3
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
    "mov " ,s ,>TOS "," ,s ,PK3 ,cr
	;
:,pick4
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
    "mov " ,s ,>TOS "," ,s ,PK4 ,cr
	;
:,2dup
	>TOSreg? 1? (
	    eligeReg
		"mov " ,s ,>TOS "," ,s ,TOS ,cr ) drop
	>NOSreg? 0? ( drop ; ) drop
    regused
    newreg >DNOS cell.reg!
	"mov " ,s ,>NOS "," ,s ,NOS ,cr
	;
:,2over
	>TOSreg? 1? (
	    eligeReg
		"mov " ,s ,>TOS "," ,s ,PK2 ,cr ) drop
	>NOSreg? 0? ( drop ; ) drop
    regused
    newreg >DNOS cell.reg!
	"mov " ,s ,>NOS "," ,s ,PK3 ,cr
	;
|------- EXEC
:,execr
	dup @ $ff and 			| word ;
	16 =? ( "jmp ecx" )( "call ecx" ) nip
	,s ,cr
	;

:,EXEC | v --
|	d.tos cellVAR -? ( 2drop ,EXECPP ; ) 2drop
	"mov ecx," ,s ,TOS ,cr
	,execr ;

|------- PILAR
:,>R
|	toknow 8 >> 1? ( drop d.pop r.push ; ) drop
|	"push " ,s ,TOS ,cr d.drop
	;

:,R>
|	toknow 8 >> 1? ( drop r.pop d.push ; ) drop
|	d.dup d.tos needReg "pop " ,s ,TOS ,cr
	;

:,R@
	>TOSreg? 0? ( drop RTOS >DTOS cell.cpy ; ) drop
	eligeReg
    "mov " ,s ,>TOS "," ,s ,RTOS ,cr
	;

|----------------------
:,AND
|	dnos cellREG
	"and " ,s ,NOS "," ,s ,TOS ,cr
	;
:,OR
|	dnos cellREG
	"or " ,s ,NOS "," ,s ,TOS ,cr
	;
:,XOR
|	dnos cellREG
	"xor " ,s ,NOS "," ,s ,TOS ,cr
	;

:,+val
	dnos cell.add? 1? ( dnos cellflat ) drop
	dtos cell.value dnos cell.add ;

:,+
|	dtos cell.val? 0? ( drop ,+val ; ) drop
	"add " ,s ,NOS "," ,s ,TOS ,cr
	;

:,-val
	dnos cell.add? 1? ( dnos cellflat ) drop
	dtos cell.value neg dnos cell.add ;
:,-
|	dtos cell.val? 0? ( drop ,-val ; ) drop
	"sub " ,s ,NOS "," ,s ,TOS ,cr
	;

|------ mult
:,*
|	dnos cellREG
	"imul " ,s ,NOS "," ,s ,TOS ,cr
	;

|----- division by constant
| http://www.flounder.com/multiplicative_inverse.htm

#ad		| d absoluto
#t #anc #p
#q1 #r1
#q2 #r2

#divm	| magic mult
#divs   | shift mult

:calcstep
	1 'p +!
	q1 2* 'q1 ! r1 2* 'r1 !
	r1 anc >=? ( 1 'q1 +! anc neg 'r1 +! ) drop
	q2 2* 'q2 ! r2 2* 'r2 !
	r2 ad >=? ( 1 'q2 +! ad neg 'r2 +! ) drop
	;

:calcmagic | d --
	dup abs 'ad !
    $80000000 over 31 0>> + 't !
    t dup 1- swap ad mod - 'anc !
    31 'p !
    $80000000 anc / abs 'q1 !
    $80000000 q1 anc * - abs 'r1 !
	$80000000 ad / abs 'q2 !
	$80000000 q2 ad * - abs 'r2 !
	( calcstep
		ad r2 -	| delta
		q1 =? ( r1 0? ( swap 1+ swap ) drop )
		q1 >? )( drop ) drop
	q2 1+
	swap -? ( drop neg )( drop )
	'divm ! p 32 - 'divs ! ;


:,cte/
	dtos cell.value
	calcmagic

	"cdq" ,ln
	"imul $" ,s divm ,h ,cr
	"shr edx," ,s divs ,d ,cr
	"mov eax,edx" ,ln
	"cdq" ,ln |"shr edx,31" ,ln
	"sub eax,edx" ,ln
	;

:,/
	dnos cellEAX
	usoEDX

	| dtos cell.val? 0? ( drop ,cte/ ; ) drop 	| si dtos es cte

	dtos cellREGMEM
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
	>dtos setEAX
	;

|----------------
:,cte/MOD
	dtos cell.value
	calcmagic
	"mov ebx,eax" ,ln

	"cdq" ,ln
	"imul $" ,s divm ,h ,cr
	"shr edx," ,s divs ,d ,cr
	"mov eax,edx" ,ln
	"cdq" ,ln |"shr edx,31" ,ln
	"sub eax,edx" ,ln

	"imul edx,eax," ,s dtos cell.value ,cr
	"sub edx,ebx" ,ln
	;

:,/MOD
	| dtos cell.val? 0? ( drop ,cte/MOD ; ) drop 	| si dtos es cte
	dnos cellEAX dtos cellREGMEM usoEDX
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
	>dnos setEAX
	>dtos setEDX
	;

|----------------
:,cteMOD
	dtos cell.value
	calcmagic
	|**
	;

:,MOD
	| dtos cell.val? 0? ( drop ,cteMOD ; ) drop 	| si dtos es cte
	dnos cellEAX dtos cellREGMEM usoEDX
	"cdq" ,ln
	"idiv " ,s ,TOS ,cr
	>dtos setEDX
	;

|----------------
:,*/
	dpk2 cellEAX dtos cellREGMEM dnos cellREGMEM usoEDX
	"cdq" ,ln
	"imul " ,s ,NOS ,cr
	"idiv " ,s ,TOS ,cr
	>dtos setEAX
	;

|----------------
:,*>>
	dpk2 cellEAX dnos cellREGMEM dtos cellECXCTE usoEDX

	"cdq" ,ln
	"imul " ,s ,NOS ,cr
	"shrd eax,edx," ,s ,TOSb ,cr
|	"shr edx," ,s ,TOSb ,cr | no hace falta!!
	>dtos setEAX
	;

|----------------
:,<</
	dpk2 cellEAX
	dnos cellREGMEM
	dtos cellECXCTE
	usoEDX

	"cdq" ,ln
    "shld edx,eax," ,s ,TOSb ,cr
	"shl eax," ,s ,TOSb ,cr
	"idiv " ,s ,NOS ,cr
	>dtos setEAX
	;

|----------------
:,<<
|	dnos cellREG
	dtos cellECXCTE
	"sal " ,s ,NOS "," ,s ,TOSb ,cr
	;

:,>>
	| dtos=31 & dnos=eax --> "cdq" dtos=edx
|	dnos cellREG
	dtos cellECXCTE
	"sar " ,s ,NOS "," ,s ,TOSb ,cr
	;

:,0>>
|	dnos cellREG
	dtos cellECXCTE
	"shr " ,s ,NOS "," ,s ,TOSb ,cr
	;

:,R>>	| no implementada
	dnos cellREG
	dtos cellECXCTE
	"ror " ,s ,NOS "," ,s ,TOSb ,cr
	;

:,ABS
	dtos cellREG
	usoEDX
	dtos cellREG? 0? ( | EAX
		"cdq" ,ln
		)(
		"mov edx," ,s ,TOS ,cr
		"sar edx,31" ,ln
		) drop
	"add " ,s ,TOS ",edx" ,ln
	"xor " ,s ,TOS ",edx" ,ln
	;

:,CLZ
|	dtos cellREG

|	trace


	"bsr " ,s ,TOS  "," ,s ,TOS ,cr
	"xor " ,s ,TOS ",31" ,ln ;
:,NOT
	dtos cellREG
	"not " ,s ,TOS ,cr ;
:,NEG
	dtos cellREG
	"neg " ,s ,TOS ,cr ;

:,1+
	dtos cell.add? 1? ( dtos cellflat ) drop
	1 dtos cell.add ;

:,4+
	dtos cell.add? 1? ( dtos cellflat ) drop
	4 dtos cell.add ;

:,1-
	dtos cell.add? 1? ( dtos cellflat ) drop
	-1 dtos cell.add ;

:,2/
|	cellflat
	"sar " ,s ,TOS ",1" ,ln ;

:,2*
	dtos cell.shf? 1? ( drop cellflat ) drop
	2 dtos cell.shf ;

|	"sal " ,s ,TOS ",1" ,ln ;

    |------ MEMORIA
:,@
	"mov " ,s ,TOS ",dword [" ,s ,TOS "]" ,ln ;
:,C@
	"movsx " ,s ,TOS ",byte [" ,s ,TOS "]" ,ln ;
:,W@
	"movsx " ,s ,TOS ",word [" ,s ,TOS "]" ,ln ;

:,!
	"mov dword [" ,s ,TOS "]," ,s ,NOS ,cr
	;
:,C!
	"mov byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	;
:,W!
	"mov word [" ,s ,TOS "]," ,s ,NOSw ,cr
	;

:,+!
	"add dword [" ,s ,TOS "]," ,s ,NOS ,cr
	;
:,W+!
	"add word [" ,s ,TOS "]," ,s ,NOSw ,cr
	;
:,C+!
	"add byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	;

:,!+
	"mov dword [" ,s ,TOS "]," ,s ,NOS ,cr
	"add " ,s ,TOS ",4" ,ln
	;
:,W!+
	"mov word [" ,s ,TOS "]," ,s ,NOSw ,cr
	"add " ,s ,TOS ",2" ,ln
	;
:,C!+
	"mov byte [" ,s ,TOS "]," ,s ,NOSb ,cr
	"add " ,s ,TOS ",1" ,ln
	;

:,@+
	"mov " ,s ,TOS ",dword [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",4" ,ln ;
:,W@+
	"movsx " ,s ,TOS ",word [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",2" ,ln ;
:,C@+
	"movsx " ,s ,TOS ",byte [" ,s ,NOS "]" ,ln
	"add " ,s ,NOS ",1" ,ln ;

:,>A
	"mov esi," ,s ,TOS ,cr
	;
:,A>
	"mov " ,s ,>TOS ",esi" ,s ,cr
	;
:,A@
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
	"mov " ,s ,>TOS ",dword [esi]" ,s ,cr
	;
:,A!
	"mov dword [esi]," ,s ,TOS ,cr
	;
:,A+
	"add esi," ,s ,TOS ,cr
	;
:,A@+
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
	"mov " ,s ,>TOS ",dword [esi]" ,s ,cr
	"add esi,4" ,ln
	;
:,A!+
	"mov dword [esi]," ,s ,TOS ,cr
	"add esi,4" ,ln
	;

:,>B
	"mov edi," ,s ,TOS ,cr
	;
:,B>
	"mov " ,s ,>TOS ",edi" ,s ,cr
	;
:,B@
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
	"mov " ,s ,>TOS ",dword [edi]" ,s ,cr
	;
:,B!
	"mov dword [edi]," ,s ,TOS ,cr
	;
:,B+
	"add edi," ,s ,TOS ,cr
	;
:,B@+
	>TOSreg? 0? ( drop DTOS >DTOS cell.cpy ; ) drop
	eligeReg
	"mov " ,s ,>TOS ",dword [edi]" ,s ,cr
	"add edi,4" ,ln
	;
:,B!+
	"mov dword [edi]," ,s ,TOS ,cr
	"add edi,4" ,ln
	;
|--------- Sistema
|#syscons "XRES" "YRES" "FREE_MEM" "SYSFRAME" "SYSXYM" "SYSBM" "SYSKEY"

:,SW
	0 VALUE >DTOS cell.Cte!
|fullscreen 1? ( >DTOS cell.mem  ) drop
	;
:,SH
	1 VALUE >DTOS cell.Cte!
|fullscreen 1? ( >DTOS cell.mem  ) drop
	;

:,MEM
	2 VALUE >DTOS cell.Cte!
	>DTOS cell.mem ;

:,FRAMEV
	3 VALUE >DTOS cell.Cte!	;

:,BMOUSE
	5 VALUE >DTOS cell.Cte!
	>DTOS cell.mem ;

:,KEY
	6 VALUE >DTOS cell.Cte!
	>DTOS cell.mem ;

:,KEY! | v --
|	d.tos needReadM | no memoria []
	"mov [SYSKEY]," ,s ,TOS ,cr
	;

:,XYMOUSE | -- x y
	"mov " ,s ,>TOS ",[SYSXYM]" ,ln
	"mov " ,s ,>NOS "," ,s ,>TOS ,cr
	"and " ,s ,>NOS ",$ffff" ,ln
	"shr " ,s ,>TOS ",16" ,ln
	;

:,CNTJOY
|	"xor eax,eax" ,ln
;
:,GETJOY
:,SLOAD
:,SPLAY
:,SINFO
:,SSET  ;

:,DOCINI
:,DOCEND
:,OPENURL	| url header buff -- buff/0
:,DOCAT     | x y --
:,DOCLINE	| x y --
:,DOCTEXT	| "tt" --
:,DOCFONT	| size angle "font" --
:,DOCBIT	| bitmap x y --
:,DOCRES	| -- xmax ymax
:,DOCSIZE	| "tt" -- w h
	;

:,MOVE
	"rep movsd" ,ln
	;
:,MOVE>
	"lea esi,[esi+ecx*4-4]" ,ln
	"lea edi,[edi+ecx*4-4]" ,ln
	"std" ,ln
	"rep movsd" ,ln
	"cld" ,ln
	;
:,FILL
	"rep stosd" ,ln
	;

:,CMOVE
	"rep movsb" ,ln
	;
:,CMOVE>
	"lea esi,[esi+ecx-1]" ,ln
	"lea edi,[edi+ecx-1]" ,ln
	"std" ,ln
	"rep movsb" ,ln
	"cld" ,ln
	;
:,CFILL
	"rep stosb" ,ln

|	"mov ah,al" ,ln			| eax=(al<<24)|(al<<16)|(al<<8)|al
|	"movzs ebx,ax" ,ln
|	"shl eax,16" ,ln
|	"or eax,ebx" ,ln

|	"mov ebx,ecx" ,ln
|	"shr ecx,2" ,ln
|	"rep stosd" ,ln
|	"mov ecx,ebx" ,ln
|	"and ecx,3" ,ln
|	"rep stosb" ,ln
	;

|----------- en asmbase.txt
:,SQRT
:,MOVE :,MOVE> :,CMOVE :,CMOVE>
:,INK :,INK@ :,ALPHA
:,OP :,LINE :,CURVE :,CURVE3 :,PLINE :,PCURVE :,PCURVE3 :,POLI
:,FCOL :,FCEN :,FMAT :,SFILL :,LFILL :,RFILL :,TFILL ;

:,callsys | usapila? --
|	1? ( vpila2normal )
	drop
	dup @ $ff and | word ;
	16 =? ( "jmp " )( "call " ) nip
	,s ;

:,END		"jmp SYSEND" ,ln ;
:,FFIRST 	1 ,callsys "SYSFFIRST" ,ln ;
:,FNEXT		1 ,callsys "SYSFNEXT" ,ln 1 vpila2v ;
:,LOAD		1 ,callsys "SYSLOAD" ,ln -1 vpila2v ;
:,SAVE		1 ,callsys "SYSSAVE" ,ln -3 vpila2v ;
:,APPEND	1 ,callsys "SYSAPPEND" ,ln -3 vpila2v ;
:,UPDATE	1 ,callsys "SYSUPDATE" ,ln ;
:,MSEC		1 ,callsys "SYSMSEC" ,ln 1 vpila2v ;
:,TIME		1 ,callsys "SYSTIME" ,ln 3 vpila2v ;
:,DATE		1 ,callsys "SYSDATE" ,ln 3 vpila2v ;
:,RUN		1 ,callsys "SYSRUN" ,ln ;
:,REDRAW	0 ,callsys "SYSREDRAW" ,ln ;
:,SYSTEM	1 ,callsys "SYSYSTEM" ,ln ; | "sys" -- ret

#acompila 0
,defw ,defw ,defv ,defv 0 0
,lit ,lit ,lit ,lit ,lits
,wor ,var ,dwo ,dva
,; ,( ,)( ,) ,[ ,] ,EXEC
,0? ,+? ,-? ,1? ,=? ,<? ,>? ,<=? ,>=? ,<>? ,AND? ,NAND? | 30

,dup 0 ,over ,pick2 ,pick3 ,pick4 0 0
0 ,2dup 0 0 0 ,2over 0

,>R ,R> ,R@ 									|--- pila direcciones 52
,AND ,OR ,XOR ,NOT  							|--- logicas        56
,+ ,- ,* ,/ ,*/ ,*>> ,/MOD ,MOD ,ABS  			|--- aritmeticas | 65
,SQRT ,CLZ ,<</ ,NEG ,1+ ,4+ ,1- ,2/ ,2* ,<< ,>> ,0>> | 76
,@ ,C@ ,W@ ,! ,C! ,W! ,+! ,C+! ,W+!  			|--- memoria 85
,@+ ,!+ ,C@+ ,C!+ ,W@+ ,W!+	| 91

,>A	,A> ,A@ ,A! ,A+ ,A@+ ,A!+
,>B	,B> ,B@ ,B! ,B+ ,B@+ ,B!+

,MOVE ,MOVE> ,FILL ,CMOVE ,CMOVE> ,CFILL | 95
,MEM ,FFIRST ,FNEXT
,LOAD ,SAVE ,APPEND		|--- memoria bloques 102
,UPDATE
,XYMOUSE ,BMOUSE
,KEY! ,KEY
,CNTJOY ,GETJOY 							| 109
,MSEC ,TIME ,DATE ,END ,RUN 				|--- sistema 114
,SW ,SH ,REDRAW ,FRAMEV  						|--- pantalla

,INK ,INK@ ,ALPHA							|--- color
,OP ,LINE ,CURVE ,CURVE3 ,PLINE ,PCURVE ,PCURVE3 ,POLI		|--- dibujo
,FCOL ,FCEN ,FMAT ,SFILL ,LFILL ,RFILL ,TFILL
,SLOAD ,SPLAY ,SINFO ,SSET					|--- Sonido
,OPENURL
,DOCINI ,DOCEND ,DOCAT ,DOCLINE ,DOCTEXT ,DOCFONT ,DOCBIT ,DOCRES ,DOCSIZE  |-- impresora
,SYSTEM

:,cadatoken | adr+ t -- adr+
	$ff and 2 << 'acompila + @ 0? ( drop ; )
	exec ;

|--------
:codeini | w -- w
	dup 'nword !
	'pilac 'pilac> !
	'pilab 'pilab> !
	0 'nblock !
	0 'strpending !
	0 'nroi !
	;

:,code | w --
	codeini
	inputcells

	cellinfo

	dup dic>tok @ dup 'tokenini !
	swap dic>len@
	( 1? )( 1- swap @+
		9 ,c "; " ,s dup tokenstr ,print
		9 ,c "|" ,s nroi ,stackm " |" ,s nroi ,stackmc 	,cr

		,cadatoken swap
		"r4/compiler/code.asm" savemem | DEBUG

		1 'nroi +!
		) 2drop ;

| regIO  word -> 0 0 0 0
| bytes.. cntIn i0 i1 i2 i3 cntO o0 o1 o2 o3
|
::iniCODE
	here dup 'regIO !
	cntwords 4 <<	| 16 bytes por word
	+ 'here ! ;

:compilacode | w --
	dup 1- dic>inf @
	$81 and $80 =? ( 2drop ; )
	drop

	dup cellana
	cell2reg

	"; vreg:" ,s cntvreg 1- ,d ,cr

|	blockinfo
|	tokeninfo

	,code

	"r4/compiler/code.asm" savemem | DEBUG

	;

::,generateCODE
	0 ( cntwords <? )(
		dup dic>inf @
		1 nand? ( over compilacode )
		drop 1+ ) drop ;