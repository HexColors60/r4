| r3-gencode
| PHREDA 2018
|
^./r3base.txt
^./r3asm.txt

#:ncell 0	| cnt cells
| Info de celdas
| RR WW FFFF
| R cnt de lecturas
| W cnt de escrituras
| flags........
|  $1 in W		| word
|  $2 out W
|  $4 in C		| call
|  $8 out C
| $10 var
| $20 dir var
| $40 dir code
| $80 copia de A en cellt
| $100 celda exec
| $800 celda ya asignada (para vreg)
| $1000 celda AD	x86
| $2000 celda C		x86
| $4000 no usar C
#:cells )( 1024
#:cellt )( 1024 | token de origen o celda
#:cellv )( 1024 | vida de celda | ff iii fff

:newcell | -- nro
	ncell
	0 over 2 << 'cells + !
	0 over 2 << 'cellt + !
	ncode over 2 << 'cellv + ! | inicio de vida
	dup 1+ 'ncell !
	;

:setcell | nro -- nro
	0 over 2 << 'cells + !
	0 over 2 << 'cellt + !
	ncode over 2 << 'cellv + ! | inicio de vida
	;

:endlive | nro --
	ncode 10 << swap 2 << 'cellv + +!  ;

|----- division by constant
| http://www.flounder.com/multiplicative_inverse.htm

#ad		| d absoluto
#t #anc #p
#q1 #r1
#q2 #r2

#divm	| magic mult
#divs   | shift mult

:calcstep
	1 'p +!
	q1 2* 'q1 ! r1 2* 'r1 !
	r1 anc >=? ( 1 'q1 +! anc neg 'r1 +! ) drop
	q2 2* 'q2 ! r2 2* 'r2 !
	r2 ad >=? ( 1 'q2 +! ad neg 'r2 +! ) drop
	;

:calcmagic | d --
	dup abs 'ad !
    $80000000 over 31 0>> + 't !
    t dup 1- swap ad mod - 'anc !
    31 'p !
    $80000000 anc / abs 'q1 !
    $80000000 q1 anc * - abs 'r1 !
	$80000000 ad / abs 'q2 !
	$80000000 q2 ad * - abs 'r2 !
	( calcstep
		ad r2 -	| delta
		q1 =? ( r1 0? ( swap 1+ swap ) drop )
		q1 >? )( drop ) drop
	q2 1+
	swap -? ( drop neg )( drop )
	'divm ! p 'divs ! ;

|--- ajuste por signo
:signadj!+ | --
	$23 code!+ 	| dup
	31 cte!+ 	| 31
	$4c code!+ 	| >>
	$3a code!+ 	| -
	;

|-----------------------------------
:idec | --
	getcte push.nro ;

:istr
	getval push.str ;

:ivar
	getval
	| inline?

	push.wrd
	;

:idwor
	getval push.wrd	;

:idvar
	getval push.wrd	;


:iwor
	getval
	dup dic>du
|	dup ( 1? )( 1- tosoutC d.dropv ) drop
|	+ ( 1? )( 1- newcell d.push tosinC ) drop
	3drop
	;

:i;
:i( 
:i) 
:i[ 
:i]
	;

:iex
|	lastdircode
|	dup ( 1? )( 1- tosoutC d.dropv ) drop
|	+ ( 1? )( 1- newcell d.push tosinC ) drop
	;

:i0? 
:i1? 
:i+? 
:i-? 
:i<? 
:i>? 
:i=? 
:i>=? 
:i<=? 
:i<>? 
:iA? 
:iN? 
:iB?
	;

:i>R 
:iR> 
:iR@
	;

:iAND
	nro2stk 0? ( drop .AND ; ) drop

	.drop ;
:iOR
	nro2stk 0? ( drop .OR ; ) drop

	.drop ;
:iXOR
	nro2stk 0? ( drop .XOR ; ) drop

	.drop ;
:iNOT
	nro1stk 0? ( drop .NOT ; ) drop

	;
:iNEG
	nro1stk 0? ( drop .NEG ; ) drop

	;
:i+
	nro2stk 0? ( drop .+ ; ) drop

	.drop ;
:i-
	nro2stk 0? ( drop .- ; ) drop

	.drop ;

|---------------- *
| 8 * --> 3 <<
:*pot
	31 swap clz - cte!+
	$4b code!+
	;

| 7 * --> dup 3 << swap -
:*pot-1
	$23 code!+	| dup
	32 swap clz - cte!+
	$4b	code!+	| <<
	$29	code!+	| swap
	$3a code!+ | -
	;

:*nro

	dup 1- nand? ( *pot ; )
	dup 1+ nand? ( *pot-1 ; )
	drop
	;

:i*
	nro2stk 0? ( drop .* ; ) drop
	nro1stk 0? ( drop *nro ; ) drop

	.drop ;

|---- cte / --> divm divs *>> dup 31 >> -
:/cte
	calcmagic
	divs cte!+
	divm cte!+
	$3e code!+ 		| *>>
	signadj!+ ;

|----  2 / --> dup 31 >> + 2/
:/cte2
	$23 code!+ | dup 31
	31 cte!+
	$4d code!+ | 0>>
	$39	code!+ | +
	$49	code!+ | 2/
	;

|----  4 / --> dup 31 >> 30 0>> + 2 >>
:/nro

	dup 1- and? ( /cte ; )
	2 =? ( /cte2 ; )
	swap
	31 cte!+
	$23 code!+
	$4c code!+ | >>
	33 32 pick3 clz - - cte!+ |30
	$4d code!+ | 0>>
	$39	code!+	| +
	31 rot clz - cte!+ | 2
	$4c code!+ | >>
	;

:i/
	nro2stk 0? ( drop ./ ; ) drop
	nro1stk 0? ( drop /nro ; ) drop

	.drop ;


:i*/
	nro3stk 0? ( drop .*/ ; ) drop

	.2drop ;


|---------------- /MOD
:/modcte
	dup >r
	calcmagic
	divm cte!+
	$23 code!+
	divs cte!+
	$3e  code!+ 		| *>>
	signadj!+

	$29	code!+	| swap
	$25	code!+	| over

	r> cte!+	| NRO
	$3B	code!+	| *
	$3A	code!+	| -
	;

|----  8 /mod --> dup / swap mod
:/MODnro
	
	dup 1- and? ( /modcte ; )
	swap
    $23 code!+
	$23 code!+
    31 cte!+ | 31
	$4c code!+ | >>
	33 32 pick3 clz - - cte!+ |30
	$4d code!+ | 0>>
	$39	code!+	| +
	31 pick2 clz - cte!+ 	| 2
	$4c code!+ | >>
	$29	code!+	| swap
	$23 code!+ | dup
	31 cte!+ |31
	$4c code!+ | >>
	33 32 pick3 clz - - cte!+
	$4d code!+	| 0>>
	$29	code!+	| swap
	$25	code!+	| over
	$39	code!+	| +
	1- cte!+  | mask
	$35 code!+	| AND
	$29	code!+	| swap
	$3A	code!+	| -
	;


:i/MOD
	nro2stk 0? ( drop ./MOD ; ) drop
	nro1stk 0? ( drop /MODnro ; ) drop

	;

|---------------- MOD
:modcte
	dup >r
	calcmagic
	divm cte!+
	$23 code!+
	divs cte!+
	$3e code!+ 		| *>>
	signadj!+
	r> cte!+	| NRO
	$3B	code!+	| *
	$3A	code!+	| -
	;

|----  8 mod --> $7 and
|	dup 31 >> (33-4)29 0>> swap over + 7 and swap -
:modnro
	
	dup 1- and? ( modcte ; )
	31 cte!+
	$23 code!+ | dup 31
	$4c code!+ | >>
	33 32 pick3 clz - - cte!+
	$4d code!+	| 0>>
	$29	code!+	| swap
	$25	code!+	| over
	$39	code!+	| +
	1- cte!+ | mask
	$35 code!+	| AND
	$29	code!+	| swap
	$3A	code!+	| -
	;


:iMOD
	nro2stk 0? ( drop .MOD ; ) drop
	nro1stk 0? ( drop MODnro ; ) drop
	.drop ;


:iABS
	nro1stk 0? ( drop .ABS ; ) drop

	;
:iSQRT
	nro1stk 0? ( drop .SQRT ; ) drop

	;
:iCLZ
	nro1stk 0? ( drop .CLZ ; ) drop

	;
:i<<
	nro2stk 0? ( drop .<< ; ) drop

	.drop ;
:i>>
	nro2stk 0? ( drop .>> ; ) drop

	.drop ;
:i>>>
	nro2stk 0? ( drop .>>> ; ) drop

	.drop ;
:i*>>
	nro3stk 0? ( drop .*>> ; ) drop

	.2drop ;
:i<</
	nro3stk 0? ( drop .<</ ; ) drop

	.2drop ;


:i@ 
:iC@
:iD@ 
:i@+ 
:iC@+ 
:iD@+
:i! 
:iC! 
:iD! 
:i!+
:iC!+
:iD!+
:i+!
:iC+!
:iD+!
	;

:i>A 
:iA> 
:iA@ 
:iA! 
:iA+ 
:iA@+ 
:iA!+
:i>B 
:iB> 
:iB@ 
:iB! 
:iB+ 
:iB@+ 
:iB!+
	;

:iMOVE 
:iMOVE> 
:iFILL
:iCMOVE 
:iCMOVE> 
:iCFILL
:iDMOVE 
:iDMOVE> 
:iDFILL
:iSYSCALL 
:iSYSMEM
	;

#vmc
0 0 0 0 0 0 0		| 0 1 2 3 4 5 6

idec idec idec idec istr    | 7 8 9 a b
iwor ivar idwor idvar		| c d e f

i; i( i) i[ i] iEX			| 10..15

i0? i1? i+? i-? i<? i>? i=? i>=? i<=? i<>? iA? iN? iB?	| 16..22

.DUP .DROP .OVER .PICK2 .PICK3 .PICK4 .SWAP .NIP		| 23..2A
.ROT .2DUP .2DROP .3DROP .4DROP .2OVER .2SWAP			| 2B..31

i>R iR> iR@                                             | 32..34

iAND iOR iXOR iNOT iNEG									| 35..39
i+ i- i* i/ i*/                                         | 3A..3E
i/MOD iMOD iABS iSQRT iCLZ
i<< i>> i>>> i*>> i<</

i@ iC@ iD@ i@+ iC@+ iD@+
i! iC! iD! i!+ iC!+ iD!+
i+! iC+! iD+!

i>A iA> iA@ iA! iA+ iA@+ iA!+
i>B iB> iB@ iB! iB+ iB@+ iB!+

iMOVE iMOVE> iFILL
iCMOVE iCMOVE> iCFILL
iDMOVE iDMOVE> iDFILL
iSYSCALL iSYSMEM

|------------------------------------------
:tocode | adr token -- adr
	$ff and 2 << 'vmc + @ exec ;


|-----------------------------
:gencode2 | adr --
	dup 8 + @
	1 and? ( 2drop ; )	| code
	12 >> $fff and 0? ( 2drop ; )	| no calls
	drop

	codeini

    "--------------------------" ,s ,cr
	dup dicc - 4 >> ,codeinfo ,cr
	dup 12 + @	| mov
	$f and 		| uso
	DeepStack
	,printstk

	dup adr>dicname ,s ":" ,s ,cr

	adr>toklen
	( 1? )( 1- swap
		@+ tocode
		swap ) 2drop

	'bcode ( bcode> <? )(
		@+
		dup $ff and r3tokenname "; %s " ,print
		dup 8 >> 1? ( "%h " ,print )( drop )
		,printstk
		codestep
		) drop

	;

:gencode | adr --
	dup 8 + @
	1 and? ( 2drop ; )	| code
	12 >> $fff and 0? ( 2drop ; )	| no calls
	drop

    "--------------------------" ,s ,cr
	dup dicc - 4 >> ,codeinfo ,cr
	dup 12 + @	| mov
	$f and 		| uso
	DeepStack
	,printstk
	dup adr>dicname ,s ":" ,s ,cr
	adr>toklen
	( 1? )( 1- >r
		@+
		dup $ff and r3tokenname "; %s " ,print
		dup 8 >> 1? ( "%h " ,print )( drop )
		,printstk

		codestep
|		"r4asm/code.asm" savemem | debug

		r> ) 2drop
	,cr ;

:debugblok
	";---- bloques ----" ,s
	blok >a
	,cr
	nbloques ( 1? )( 1-
		nbloques over - "; %d. " ,print
		a@+ a@+ "%d %d " ,print ,cr
		) drop ;

::r3-gencode
	mark
	";---r3 compiler code.asm" ,ln
	dicc ( dicc> <? )(
		dup gencode2
		16 + ) drop

	debugblok

	0 ,c
	"r4asm/code.asm"
	savemem
	empty ;

