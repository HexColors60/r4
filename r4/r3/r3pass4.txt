| r3pass4.txt
| pass4 - static stack analisys
| PHREDA 2019
|---------------------------------
^./r3base.txt


#MAXINLINE 12

#:cntuwords
#:cntuvars

#nivel	0

#usoD	0
#deltaD	0	| pila de datos
#deltaD1fin | pila de datos en el 1er fin
#deltaR	0	| pila de retorno
#:maxdepth

#flags	0
#cntfin
#pano		| anonima
#cano


| uso dD dR tipo
#deltainternos (
0 0 0 0		|0
0 0 0 0		|1 :  | --  define codigo
0 0 0 0		|2 :: | --  define codigo
0 0 0 0		|3 #  | --  define variable
0 0 0 0		|4 #: | --  define variable
0 0 0 0		|5 |  | -- comentario
0 0 0 0		|6 ^  | -- include
0 1 0 0		|7 1  | -- n 	numero decimal
0 1 0 0		|8 $  | -- n	numero hexa
0 1 0 0		|9 %  | -- n	numero binario
0 1 0 0		|A .  | -- n	numero punto fijo
0 1 0 9		|B "  | -- n	string
0 0 0 1		|C w  | x -- x  word <---- debe ser calculado
0 1 0 11	|D v  | -- n  var
0 1 0 11	|E 'w | -- n  dir word
0 1 0 11	|F 'v | -- n  dir var
			|------------------------- ) #deltamacros (
0 0 0 7		|10 ; | fin de palabra (12)
0 0 0 2		|11 (
0 0 0 4		|13 )
0 0 0 5		|14 [
0 1 0 6		|15 ]
1 -1 0 10	|16 EX  x/0 --
1 0 0 0		|	0? a -- a
1 0 0 0		|	1? a -- a
1 0 0 0		|	+? a -- a
1 0 0 0		|	-? a -- a
2 -1 0 0	|	<?  ab -- a
2 -1 0 0	|	>?  ab -- a
2 -1 0 0	|	=?  ab -- a
2 -1 0 0	|	>=? ab -- a
2 -1 0 0	|	<=? ab -- a
2 -1 0 0	|20 <>? ab -- a
2 -1 0 0	|AN?  ab -- a
2 -1 0 0	|NA? ab -- a
3 -2 0 0	|BTW? abc -- a
1  1 0 0	|DUP    a -- aa
1 -1 0 0	|DROP  a --
2 1 0 0		|OVER   ab -- aba
3 1 0 0		|PICK2  abc -- abca
4 1 0 0		|PICK3  abcd -- abcda
5 1 0 0		|PICK4  abcde -- abcdea
2 0 0 0		|SWAP   ab -- ba
2 -1 0 0	|NIP   ab -- b
3 0 0 0		|ROT	abc -- bca
2 2 0 0		|2DUP   ab -- abab
2 -2 0 0	|2DROP ab --
3 -3 0 0	|3DROP abc --
4 -4 0 0	|4DROP abcd --
4 2 0 0		|30 2OVER  abcd -- abcdab
4 0 0 0		|2SWAP  abcd -- cdab
1 -1 1 8	|>R    a -- R: -- a
0 1 -1 8	|R>    -- a R: a --
0 1 0 8		|R@      -- a R: a -- a

2 -1 0 0	|35 AND	ab -- c
2 -1 0 0	|OR    ab -- c
2 -1 0 0	|XOR   ab -- c
1 0 0 0		|NOT    a -- b
1 0 0 0		|NEG    a -- b
2 -1 0 0	|+		ab -- c
2 -1 0 0	|-     ab -- c
2 -1 0 0	|*     ab -- c	3b
2 -1 0 0	|/     ab -- c
3 -2 0 0	|*/    abc -- d
2 0 0 0		|/MOD   ab -- cd
2 -1 0 0	|40MOD    ab -- c
1 0 0 0		|ABS    a -- b
1 0 0 0		|SQRT	a -- b
1 0 0 0		|CLZ	a -- b
2 -1 0 0	|<<    ab -- c    4b
2 -1 0 0	|>>    ab -- c
2 -1 0 0	|>>>    ab -- c
3 -2 0 0	|*>>   abc -- d
3 -2 0 0	|<</	abc -- d

1 0 0 0		|@      a -- b
1 0 0 0		|C@     a -- b
1 0 0 0		|50W@     a -- b
1 1 0 16	|@+     a -- bc
1 1 0 16	|C@+    a -- bc
1 1 0 16	|W@+    a -- bc

2 -2 0 16	|!     ab --
2 -2 0 16	|C!    ab --
2 -2 0 16	|W!    ab --
2 -1 0 16	|58!+    ab -- c
2 -1 0 16	|5aC!+   ab -- c
2 -1 0 16	|5cW!+   ab -- c
2 -2 0 16	|+!    ab --
2 -2 0 16	|C+!   ab --
2 -2 0 16	|W+!   ab --

1 -1 0 12	|>A
0 1 0 13	|A>
0 1 0 13	|A@
1 -1 0 13 	|A!
1 -1 0 13	|A+
0 1 0 13	|A@+
1 -1 0 13	|A!+

1 -1 0 14	|>B
0 1 0 15	|B>
0 1 0 15	|B@
1 -1 0 15 	|B!
1 -1 0 15	|B+
0 1 0 15	|B@+
1 -1 0 15	|B!+

3 -3 0 16	|MOVE  abc --
3 -3 0 16	|MOVE> abc --
3 -3 0 16	|FILL abc --
3 -3 0 16	|CMOVE abc --
3 -3 0 16	|CMOVE> abc --
3 -3 0 16	|CFILL abc --
3 -3 0 16	|QMOVE abc --
3 -3 0 16	|QMOVE> abc --
3 -3 0 16	|QFILL abc --

| syscall
| sysmem

0 1 0 0		|MEM	-- a
1 0 1 0		|FFIRST   a -- b
0 1 0 0		|FNEXT     -- a
2 -1 0 0	|LOAD   ab -- c
3 -3 0 0	|SAVE   abc --
3 -3 0 0	|APPEND   abc --

1 0 0 0		|UPDATE  a -- a
0 2 0 0		|XYMOUSE -- ab
0 1 0 0		|BMOUSE  -- a
1 -1 0 0	|IKEY!  a --
0 1 0 0		|KEY     -- a
0 1 0 0		|CNTJOY  -- a
0 1 0 0		|GETJOY  -- a

0 1 0 0		|MSEC    -- a
0 3 0 0		|TIME    -- abc
0 3 0 0		|DATE    -- abc
0 0 0 0		|END     --
1 -1 0 0	|RUN    a --
0 1 0 0		|SW      -- a
0 1 0 0		|SH      -- a
0 0 0 0		|REDRAW  --
0 1 0 0		|FRAMEV  -- a

)


|------------- recorre cada palabra
#pilaint )( 1024
#pilaint> 'pilaint

:pushvar
	deltaD deltaR
	pilaint> !+ !+ 'pilaint> ! ;

:popvar
	pilaint> 8 - dup 'pilaint> !
	@+ 'deltaR ! @ 'deltaD ! ;

:dropvar
	-8 'pilaint> +! ;

|---- Anonimas
:es[
|	pushvar
|	1 'pano +! 1 'cano +!
	;

:es]
|	popvar
|    -1 'pano +!
|	1 'deltad +!
	; | deja direccion en pila

:es(
:es)
	;
|----------------------
:esFin
	pano 1? ( drop ; ) drop
	cntfin 0? ( deltaD 'deltaD1fin ! ) drop
	1 'cntfin +! ;

|--------------------
:usoDcalc | u --
	deltaD swap -
	usoD min 'usoD ! ;

| adr adrt t tabla
:esPal | palabra
	dup 4 - @ 8 >>	| obtener palabra
	pick2 =? ( drop $20 flags or 'flags ! ; ) | es recursiva?
    dup dic>inf @ 24 >> 1+ 'nivel !
	dic>mov @
|	dup 12 << 28 >> 'deltaR +! | no se propaga, es flujo de ejecucion
	dup 16 << 24 >> neg usoDcalc | calculado es negativo!!
	24 << 24 >> 'deltaD +!
	$200 flags or 'flags !
	;
|** falta calcular cuando el flag $200 no esta en la palabra llamada

:esStr | calcula deltaD de string
	|dup 4 - @ tok>mem strusestack nip neg
	1
	'deltaD +! ;

#lastdircode

:esExe | calcular deltaD de palabra llamada
	lastdircode	| averiguar palabra en pila !!!

	dup dic>inf @ 24 >> 1+ 'nivel !

	dic>mov @
|	dup 12 << 28 >> 'deltaR +! | no se propaga, es flujo de ejecucion
	dup 16 << 24 >> neg usoDcalc
	24 << 24 >> 'deltaD +!
	;

:esWordV | guarda ultima referencia para exec,
	$200 flags or 'flags !
	dup 4 - @ 8 >> 'lastdircode ! ;
|** falta no agregar si no tiene mov de pila
|** falta calcular cuando el flag $200 no esta en la palabra llamada

:V0 ;
:inA	flags $40000600 or 'flags ! ;
:usoA   flags $600 or 'flags ! ;
:inB    flags $80000a00 or 'flags ! ;
:usoB   flags $a00 or 'flags ! ;
:usomem flags $200 or 'flags ! ;

#acct v0 esPal es( v0 es) es[ es] esFin v0 esStr esExe esWordV
inA usoA inB usoB usomem

:prosstoken | t --

|	dup r3tokenname slog

	2 << 'deltainternos +
	c@+ usoDcalc
	c@+ 'deltaD +!
	deltaD maxdepth max 'maxdepth !
	c@+ 'deltaR +!
	c@ 2 << 'acct + @ exec ;

|-----------------------------
:resetvars | --
	0 dup 'usoD ! dup 'deltaD ! dup 'deltaR !
	dup 'nivel ! dup 'flags ! dup 'cntfin !
	dup 'pano ! 'cano !
	'pilaint 'pilaint> !
	0 'maxdepth !
	;

:inlinemark
|	$fc nand? (  | no dir, no r, no ;;, no []
|		pick2
|		cntwords 1- <? (
|			dic>len@ MAXINLINE <? ( drop $100 or )( drop ) | inline
|			)( drop )
|		)
	;


:setvars | nro -- nro
	cntfin 1 >? ( $10 flags or 'flags ! ) drop	| +1;
	cano 1? ( $40 flags or 'flags ! ) drop 		| anon
	deltaR 1? ( $8 flags or 'flags ! ) drop


	nivel 24 <<
	flags or
	over dic>inf dup @
	rot or
	inlinemark
	swap !

	deltaR $f and 8 <<
	usoD $ff and or 8 <<
	cntfin 0? ( deltaD )( deltaD1fin ) nip
	$ff and or
	over dic>mov dup @ rot or swap !
	;

|----------------------------
|----- analiza codigo
|----------------------------
:analisiscode | nro -- nro
	resetvars
	dup dic>toklen
	( 1? )( 1- swap
		@+ $ff and prosstoken
		swap ) 2drop
	setvars
	;

|----------------------------
|----- analiza variable
|----------------------------
#cntdv     | dir vars
#cntdc     | dir codigo
#cnts      | string
#cntn0     | no ceros (0 puede ser direccion)
#deltaS

:copydeltaS | ar v -- ar v
	over 4 - @ 8 >> dic>mov @ 'deltaS ! ;

:sumavars | adr c -- adr
	$6 >? ( $b <? ( 
|		over 4 - @ tok>cte 1? ( 1 'cntn0 +! ) drop
		1 'cntn0 +!
			 ) )		| NRO
	$b =? ( 1 'cnts +! )												| string
	$c =? ( 1 'cntdc +! copydeltaS ) $e =? ( 1 'cntdc +! copydeltaS )	| word y dir word
	$d =? ( 1 'cntdv +! ) $f =? ( 1 'cntdv +! )							| var y dir var
	drop ;

|--- info de variables
| valor               0
| direccion           1
| direccion codigo    2
| string              3
| lista valores       4
| lista direcciones   5
| lista dir codigos   6
| lista strings       7
| estructura multiple 8
|--------------------
:decodeinfov | -- iv
	cntdv cntdc or cnts or
	0? ( drop 3 <? ( 0 ; ) 4 ; ) drop | todos numeros
	cntdv cntdc or
	0? ( drop 3 <? ( 3 ; ) 7 ; ) drop | hay string, no dv ni dc
	cntdv
	0? ( drop 3 <? ( 2 ; ) 6 ; ) drop | direccion de codigo
	3 <? ( 1 )( 5 ) ;                 | direccion de dato

:resetvers
	0 'deltaS !
	0 'cntdv ! 0 'cntdc !
	0 'cnts ! 0 'cntn0 !
	;

:setvars
	dup dic>len@
	decodeinfov 6 <<
	nivel 24 << or
	flags or
	pick2 dic>inf dup @ rot or swap !
	drop

|	deltaS $fffff and
|	over dic>mov dup @ rot or swap !
	deltaS over dic>mov !
	;

:analisisvar |  nro -- nro
	resetvars
	dup dic>toklen
	( 1? )( 1- swap
		@+ $ff and sumavars
		swap ) 2drop
	setvars ;

|--------------------
:everyword | n -- n
	dup dic>call@ 0? ( drop ; ) drop

	dup dic>adr @ "::%w" slog

	dup dic>inf @ 1 and? ( drop 1 'cntuvars +! analisisvar ; )
	drop 1 'cntuwords +!
	analisiscode
	;

::r3-stage-4
	0 'cntuwords !
	0 'cntuvars !
	0 ( cntdef <? )(
		everyword
		1+ ) drop ;
