| JPGEncoder
| 2017
| from http://www.bytearray.org/?p=90
|---------------------------------
#bytenew
#bytepos
#sf			| calidad

#ZigZag
 0  1  5  6 14 15 27 28
 2  4  7 13 16 26 29 42
 3  8 12 17 25 30 41 43
 9 11 18 24 31 40 44 53
10 19 23 32 39 45 52 54
20 22 33 38 46 51 55 60
21 34 37 47 50 56 59 61
35 36 48 49 57 58 62 63

#aasf
1.0 1.387039845 1.306562965 1.175875602 1.0 0.785694958 0.541196100 0.275899379

#YQT
16  11  10  16  24  40  51  61
12  12  14  19  26  58  60  55
14  13  16  24  40  57  69  56
14  17  22  29  51  87  80  62
18  22  37  56  68 109 103  77
24  35  55  64  81 104 113  92
49  64  78  87 103 121 120 101
72  92  95  98 112 100 103  99

#UVQT
17  18  24  47  99  99  99  99
18  21  26  66  99  99  99  99
24  26  56  99  99  99  99  99
47  66  99  99  99  99  99  99
99  99  99  99  99  99  99  99
99  99  99  99  99  99  99  99
99  99  99  99  99  99  99  99
99  99  99  99  99  99  99  99

#YTable )( 256
#UVTable )( 256
#outputfDCTQuant )( 256
#fdtbl_Y )( 256
#fdtbl_UV )( 256


:]YQT 2 << 'YQT + @ ;
:]UVQT 2 << 'UVQT + @ ;
:]ZigZag 2 << 'ZigZag + @ ;

:zzYTable! ]ZigZag 2 << 'YTable + ! ;
:zzUVTable! ]ZigZag 2 << 'UVTable + ! ;

:]zzYTable

:initQuantTables |(sf:int):void
	0 ( 64 <? )(
		dup ]YQT sf * 50 + 16 << 0.01 *. 16 >> | YQT[i]*sf+50)*0.01
		1 clampmin 255 campmax over zzYTable!
		1+ ) drop
	0 ( 64 <? )(
    	dup ]UVQT sf * 50 + 16 << 0.01 *. 16 >> | UVQT[i]*sf+50)*0.01
		1 clampmin 255 campmax over zzUVTable!
		1+ ) drop
	0
	0 ( 8 <? )(
		0 ( 8 <? )(

			1+ ) drop
		1+ ) 2drop

			i = 0;
			for (var row:int = 0; row < I8; ++row)
			{
				for (var col:int = 0; col < I8; ++col)
				{
					fdtbl_Y[i]  = (1 / (YTable [ZigZag[i]] * aasf[row] * aasf[col] * 8));
					fdtbl_UV[i] = (1 / (UVTable[ZigZag[i]] * aasf[row] * aasf[col] * 8));
					i++;
				}
			}
	;

#YDC_HT |:Vector.<BitString>;
#UVDC_HT |:Vector.<BitString>;
#YAC_HT |:Vector.<BitString>;
#UVAC_HT |:Vector.<BitString>;

:computeHuffmanTbl |(nrcodes:Vector.<int>, std_table:Vector.<int>):Vector.<BitString>
			var codevalue:int = 0;
			var pos_in_table:int = 0;
			var HT:Vector.<BitString> = new Vector.<BitString>(251, true);
			var bitString:BitString;
			for (var k:int=1; k<=16; ++k)
			{
				for (var j:int=1; j<=nrcodes[k]; ++j)
				{
					HT[std_table[pos_in_table]] = bitString = new BitString();
					bitString.val = codevalue;
					bitString.len = k;
					pos_in_table++;
					codevalue++;
				}
				codevalue<<=1;
			}
			return HT;
		}

#std_dc_luminance_nrcodes 0 0 1 5 1 1 1 1 1 1 0 0 0 0 0 0 0
#std_dc_luminance_values 0 1 2 3 4 5 6 7 8 9 10 11
#std_ac_luminance_nrcodes 0 0 2 1 3 3 2 4 3 5 5 4 4 0 0 1 $7d
#std_ac_luminance_values
$01 $02 $03 $00 $04 $11 $05 $12 $21 $31 $41 $06 $13 $51 $61 $07
$22 $71 $14 $32 $81 $91 $a1 $08 $23 $42 $b1 $c1 $15 $52 $d1 $f0
$24 $33 $62 $72 $82 $09 $0a $16 $17 $18 $19 $1a $25 $26 $27 $28
$29 $2a $34 $35 $36 $37 $38 $39 $3a $43 $44 $45 $46 $47 $48 $49
$4a $53 $54 $55 $56 $57 $58 $59 $5a $63 $64 $65 $66 $67 $68 $69
$6a $73 $74 $75 $76 $77 $78 $79 $7a $83 $84 $85 $86 $87 $88 $89
$8a $92 $93 $94 $95 $96 $97 $98 $99 $9a $a2 $a3 $a4 $a5 $a6 $a7
$a8 $a9 $aa $b2 $b3 $b4 $b5 $b6 $b7 $b8 $b9 $ba $c2 $c3 $c4 $c5
$c6 $c7 $c8 $c9 $ca $d2 $d3 $d4 $d5 $d6 $d7 $d8 $d9 $da $e1 $e2
$e3 $e4 $e5 $e6 $e7 $e8 $e9 $ea $f1 $f2 $f3 $f4 $f5 $f6 $f7 $f8
$f9 $fa

#std_dc_chrominance_nrcodes 0 0 3 1 1 1 1 1 1 1 1 1 0 0 0 0 0
#std_dc_chrominance_values 0 1 2 3 4 5 6 7 8 9 10 11
#std_ac_chrominance_nrcodes 0 0 2 1 2 4 4 3 4 7 5 4 4 0 1 2 $77
#std_ac_chrominance_values
$00 $01 $02 $03 $11 $04 $05 $21 $31 $06 $12 $41 $51 $07 $61 $71
$13 $22 $32 $81 $08 $14 $42 $91 $a1 $b1 $c1 $09 $23 $33 $52 $f0
$15 $62 $72 $d1 $0a $16 $24 $34 $e1 $25 $f1 $17 $18 $19 $1a $26
$27 $28 $29 $2a $35 $36 $37 $38 $39 $3a $43 $44 $45 $46 $47 $48
$49 $4a $53 $54 $55 $56 $57 $58 $59 $5a $63 $64 $65 $66 $67 $68
$69 $6a $73 $74 $75 $76 $77 $78 $79 $7a $82 $83 $84 $85 $86 $87
$88 $89 $8a $92 $93 $94 $95 $96 $97 $98 $99 $9a $a2 $a3 $a4 $a5
$a6 $a7 $a8 $a9 $aa $b2 $b3 $b4 $b5 $b6 $b7 $b8 $b9 $ba $c2 $c3
$c4 $c5 $c6 $c7 $c8 $c9 $ca $d2 $d3 $d4 $d5 $d6 $d7 $d8 $d9 $da
$e2 $e3 $e4 $e5 $e6 $e7 $e8 $e9 $ea $f2 $f3 $f4 $f5 $f6 $f7 $f8
$f9 $fa


:initHuffmanTbl
	YDC_HT = computeHuffmanTbl(std_dc_luminance_nrcodes,std_dc_luminance_values);
	UVDC_HT = computeHuffmanTbl(std_dc_chrominance_nrcodes,std_dc_chrominance_values);
	YAC_HT = computeHuffmanTbl(std_ac_luminance_nrcodes,std_ac_luminance_values);
	UVAC_HT = computeHuffmanTbl(std_ac_chrominance_nrcodes,std_ac_chrominance_values);
	;

#bitcode:Vector.<BitString> = new Vector.<BitString>(65535, true);
#category:Vector.<int> = new Vector.<int>(65535, true);

:initCategoryNumber
			var nrlower:int = 1;
			var nrupper:int = 2;
			var bitString:BitString;
			const I15:int = 15;
			var pos:int;
			for (var cat:int=1; cat<=I15; ++cat)
			{
				|Positive numbers
				for (var nr:int=nrlower; nr<nrupper; ++nr)
				{
					pos = int(32767+nr);
					category[pos] = cat;
					bitcode[pos] = bitString = new BitString();
					bitString.len = cat;
					bitString.val = nr;
				}
				|Negative numbers
				for (var nrneg:int=-(nrupper-1); nrneg<=-nrlower; ++nrneg)
				{
					pos = int(32767+nrneg);
					category[pos] = cat;
					bitcode[pos] = bitString = new BitString();
					bitString.len = cat;
					bitString.val = nrupper-1+nrneg;
				}
				nrlower <<= 1;
				nrupper <<= 1;
			}
	;

| IO functions

#byteout:ByteArray;

:writeBits | (bs:BitString):void
			var value:int = bs.val;
			var posval:int = bs.len-1;
			while ( posval >= 0 )
			{
				if (value & uint(1 << posval) )
					bytenew |= uint(1 << bytepos);
				posval--;
				bytepos--;
				if (bytepos < 0)
				{
					if (bytenew == $FF)
					{
						byteout.writeByte($FF);
						byteout.writeByte(0);
					}
					else byteout.writeByte(bytenew);
					bytepos=7;
					bytenew=0;
				}
			}
	;

		| DCT & quantization core

:fDCTQuant(data:Vector.<Number>, fdtbl:Vector.<Number>):Vector.<int>
			/* Pass 1: process rows. */
			var dataOff:int=0;
			var d0:Number, d1:Number, d2:Number, d3:Number, d4:Number, d5:Number, d6:Number, d7:Number;
			var i:int;
			const I8:int = 8;
			const I64:int = 64;
			for (i=0; i<I8; ++i)
			{
                d0 = data[int(dataOff)];
				d1 = data[int(dataOff+1)];
				d2 = data[int(dataOff+2)];
				d3 = data[int(dataOff+3)];
				d4 = data[int(dataOff+4)];
				d5 = data[int(dataOff+5)];
				d6 = data[int(dataOff+6)];
				d7 = data[int(dataOff+7)];

				var tmp0:Number = d0 + d7;
				var tmp7:Number = d0 - d7;
				var tmp1:Number = d1 + d6;
				var tmp6:Number = d1 - d6;
				var tmp2:Number = d2 + d5;
				var tmp5:Number = d2 - d5;
				var tmp3:Number = d3 + d4;
				var tmp4:Number = d3 - d4;
	
				/* Even part */
				var tmp10:Number = tmp0 + tmp3;	/* phase 2 */
				var tmp13:Number = tmp0 - tmp3;
				var tmp11:Number = tmp1 + tmp2;
				var tmp12:Number = tmp1 - tmp2;

				data[int(dataOff)] = tmp10 + tmp11; /* phase 3 */
				data[int(dataOff+4)] = tmp10 - tmp11;
	
				var z1:Number = (tmp12 + tmp13) * 0.707106781; /* c4 */
				data[int(dataOff+2)] = tmp13 + z1; /* phase 5 */
				data[int(dataOff+6)] = tmp13 - z1;
	
				/* Odd part */
				tmp10 = tmp4 + tmp5; /* phase 2 */
				tmp11 = tmp5 + tmp6;
				tmp12 = tmp6 + tmp7;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5:Number = (tmp10 - tmp12) * 0.382683433; /* c6 */
				var z2:Number = 0.541196100 * tmp10 + z5; /* c2-c6 */
				var z4:Number = 1.306562965 * tmp12 + z5; /* c2+c6 */
				var z3:Number = tmp11 * 0.707106781; /* c4 */
	
				var z11:Number = tmp7 + z3;	/* phase 5 */
				var z13:Number = tmp7 - z3;
	
				data[int(dataOff+5)] = z13 + z2;	/* phase 6 */
				data[int(dataOff+3)] = z13 - z2;
				data[int(dataOff+1)] = z11 + z4;
				data[int(dataOff+7)] = z11 - z4;
	
				dataOff += 8; /* advance pointer to next row */
			}

			/* Pass 2: process columns. */
			dataOff = 0;
			for (i=0; i<I8; ++i)
			{
				d0 = data[int(dataOff)];
				d1 = data[int(dataOff + 8)];
				d2 = data[int(dataOff + 16)];
				d3 = data[int(dataOff + 24)];
		        d4 = data[int(dataOff + 32)];
				d5 = data[int(dataOff + 40)];
				d6 = data[int(dataOff + 48)];
				d7 = data[int(dataOff + 56)];
				
				var tmp0p2:Number = d0 + d7;
				var tmp7p2:Number = d0 - d7;
				var tmp1p2:Number = d1 + d6;
				var tmp6p2:Number = d1 - d6;
				var tmp2p2:Number = d2 + d5;
				var tmp5p2:Number = d2 - d5;
				var tmp3p2:Number = d3 + d4;
				var tmp4p2:Number = d3 - d4;
	
				/* Even part */
				var tmp10p2:Number = tmp0p2 + tmp3p2;	/* phase 2 */
				var tmp13p2:Number = tmp0p2 - tmp3p2;
				var tmp11p2:Number = tmp1p2 + tmp2p2;
				var tmp12p2:Number = tmp1p2 - tmp2p2;
	
				data[int(dataOff)] = tmp10p2 + tmp11p2; /* phase 3 */
				data[int(dataOff+32)] = tmp10p2 - tmp11p2;
	
				var z1p2:Number = (tmp12p2 + tmp13p2) * 0.707106781; /* c4 */
				data[int(dataOff+16)] = tmp13p2 + z1p2; /* phase 5 */
				data[int(dataOff+48)] = tmp13p2 - z1p2;
	
				/* Odd part */
				tmp10p2 = tmp4p2 + tmp5p2; /* phase 2 */
				tmp11p2 = tmp5p2 + tmp6p2;
				tmp12p2 = tmp6p2 + tmp7p2;
	
				/* The rotator is modified from fig 4-8 to avoid extra negations. */
				var z5p2:Number = (tmp10p2 - tmp12p2) * 0.382683433; /* c6 */
				var z2p2:Number = 0.541196100 * tmp10p2 + z5p2; /* c2-c6 */
				var z4p2:Number = 1.306562965 * tmp12p2 + z5p2; /* c2+c6 */
				var z3p2:Number= tmp11p2 * 0.707106781; /* c4 */
	
				var z11p2:Number = tmp7p2 + z3p2;	/* phase 5 */
				var z13p2:Number = tmp7p2 - z3p2;
	
				data[int(dataOff+40)] = z13p2 + z2p2; /* phase 6 */
				data[int(dataOff+24)] = z13p2 - z2p2;
				data[int(dataOff+ 8)] = z11p2 + z4p2;
				data[int(dataOff+56)] = z11p2 - z4p2;

				dataOff++; /* advance pointer to next column */
			}

			| Quantize/descale the coefficients
			var fDCTQuant:Number;
			for (i=0; i<I64; ++i)
			{
				| Apply the quantization and scaling factor & Round to nearest integer
				fDCTQuant = data[int(i)]*fdtbl[int(i)];
				outputfDCTQuant[int(i)] = (fDCTQuant > 0.0) ? int(fDCTQuant + 0.5) : int(fDCTQuant - 0.5);
			}
			return outputfDCTQuant;
;

| Chunk writing
:writeAPP0
	$FFE0 ,w | marker
	16 ,w | length
	$4A ,c | J
	$46 ,c | F
	$49 ,c | I
	$46 ,c | F
	0 ,c | = "JFIF",'\0'
	1 ,c | versionhi
	1 ,c | versionlo
	0 ,c | xyunits
	1 ,w | xdensity
	1 ,w | ydensity
	0 ,c | thumbnwidth
	0 ,c | thumbnheight
	;

:writeSOF0 |(width:int, height:int):void
	$FFC0 ,w | marker
	17 ,w | length, truecolor YUV JPG
	8 ,c  | precision
	height ,w
	width ,w
	3 ,c    | nrofcomponents
	1 ,c    | IdY
	$11 ,c | HVY
	0 ,c    | QTY
	2 ,c    | IdU
	$11 ,c | HVU
	1 ,c    | QTU
	3 ,c    | IdV
	$11 ,c | HVV
	1 ,c    | QTV
	;

:writeDQT
	$FFDB ,w | marker
	132 ,w	   | length
	0 ,c 'YTable 64 ( 1? )( 1- swap @+ ,c swap ) 2drop
	1 ,c 'UVTable 64 ( 1? )( 1- swap @+ ,c swap ) 2drop
	;

:writeDHT
	$FFC4 ,w | marker
	$01A2 ,w | length
	0 ,c | HTYDCinfo
	'std_dc_luminance_nrcodes 4+ 16 ( 1? )( 1- swap @+ ,c swap ) 2drop | i+1
	'std_dc_luminance_values 11 ( 1? )( 1- swap @+ ,c swap ) 2drop
	$10 ,c | HTYACinfo
	'std_ac_luminance_nrcodes 4+ 16 ( 1? )( 1- swap @+ ,c swap ) 2drop | i+1
	'std_ac_luminance_values 161 ( 1? )( 1- swap @+ ,c swap ) 2drop | i+1
	1 ,c | HTUDCinfo
	'std_dc_chrominance_nrcodes 4+ 16 ( 1? )( 1- swap @+ ,c swap ) 2drop | i+1
	'std_dc_chrominance_values 11 ( 1? )( 1- swap @+ ,c swap ) 2drop | i+1
	$11 ,c | HTUACinfo
	'std_ac_chrominance_nrcodes 4+ 16 ( 1? )( 1- swap @+ ,c swap ) 2drop | i+1
	'std_ac_chrominance_values 161 ( 1? )( 1- swap @+ ,c swap ) 2drop | i+1
	;

:writeSOS
	$FFDA ,w | marker
	12 ,w | length
	3 ,c | nrofcomponents
	1 ,c | IdY
	0 ,c | HTY
	2 ,c | IdU
	$11 ,c | HTU
	3 ,c | IdV
	$11 ,c | HTV
	0 ,c | Ss
	$3f ,c | Se
	0 ,c | Bf
	;

		| Core processing
		internal var DU:Vector.<int> = new Vector.<int>(64, true);

:processDU(CDU:Vector.<Number>, fdtbl:Vector.<Number>, DC:Number, HTDC:Vector.<BitString>, HTAC:Vector.<BitString>):Number
			var EOB:BitString = HTAC[$00];
			var M16zeroes:BitString = HTAC[$F0];
			var pos:int;

			var DU_DCT:Vector.<int> = fDCTQuant(CDU, fdtbl);
			| ZigZag reorder
			for (var j:int=0;j<I64;++j) {
				DU[ZigZag[j]]=DU_DCT[j];
			}
			var Diff:int = DU[0] - DC; DC = DU[0];
			| Encode DC
			if (Diff==0) {
				writeBits(HTDC[0]); | Diff might be 0
			} else {
				pos = int(32767+Diff);
				writeBits(HTDC[category[pos]]);
				writeBits(bitcode[pos]);
			}
			| Encode ACs
			const end0pos:int = 63;
			for (; (end0pos>0)&&(DU[end0pos]==0); end0pos--) {};
			| end0pos = first element in reverse order !=0
			if ( end0pos == 0) {
				writeBits(EOB);
				return DC;
			}
			var i:int = 1;
			var lng:int;
			while ( i <= end0pos ) {
				var startpos:int = i;
				for (; (DU[i]==0) && (i<=end0pos); ++i) {}
				var nrzeroes:int = i-startpos;
				if ( nrzeroes >= I16 ) {
					lng = nrzeroes>>4;
					for (var nrmarker:int=1; nrmarker <= lng; ++nrmarker)
						writeBits(M16zeroes);
					nrzeroes = int(nrzeroes&$F);
				}
				pos = int(32767+DU[i]);
				writeBits(HTAC[int((nrzeroes<<4)+category[pos])]);
				writeBits(bitcode[pos]);
				i++;
			}
			if ( end0pos != 63 ) { writeBits(EOB); }
			return DC;
;

		private var YDU:Vector.<Number> = new Vector.<Number>(64, true);
		private var UDU:Vector.<Number> = new Vector.<Number>(64, true);
		private var VDU:Vector.<Number> = new Vector.<Number>(64, true);

:RGB2YUV(img:BitmapData, xpos:int, ypos:int):void
			var pos:int=0;
			for (var y:int=0; y<8; ++y) {
				for (var x:int=0; x<8; ++x) {
					var P:uint = img.getPixel32(xpos+x,ypos+y);
					var R:int = (P>>16)&$FF;
					var G:int = (P>> 8)&$FF;
					var B:int = (P    )&$FF;
                    YDU[int(pos)]=((( 0.29900)*R+( 0.58700)*G+( 0.11400)*B))-$80;
					UDU[int(pos)]=(((-0.16874)*R+(-0.33126)*G+( 0.50000)*B));
					VDU[int(pos)]=((( 0.50000)*R+(-0.41869)*G+(-0.08131)*B));
					++pos;
				}
			}
	;


:JPEGEncoder | w h q -- ;(quality:int=50)
	1 clampmin
	100 clampmax
	50 <? ( 5000 swap / )( 2* 200 swap - )
	'sf !
	| Create tables
	initHuffmanTbl
	initCategoryNumber
	initQuantTables |sf

	0 'bytenew !
	0 'bytepos !

	| Add JPEG headers
	$FFD8 ,w | SOI
	writeAPP0
	writeDQT
	writeSOF0 |(image.width,image.height
	writeDHT
	writeSOS

			| Encode 8x8 macroblocks
			var DCY:Number=0;
			var DCU:Number=0;
			var DCV:Number=0;

	0 'bytenew !
	7 'bytepos !

	var width:int = image.width;
	var height:int = image.height;

			for (var ypos:int=0; ypos<height; ypos+=8)
			{
				for (var xpos:int=0; xpos<width; xpos+=8)
				{
					RGB2YUV(image, xpos, ypos);
					DCY = processDU(YDU, fdtbl_Y, DCY, YDC_HT, YAC_HT);
					DCU = processDU(UDU, fdtbl_UV, DCU, UVDC_HT, UVAC_HT);
					DCV = processDU(VDU, fdtbl_UV, DCV, UVDC_HT, UVAC_HT);
				}
			}

			| Do the bit alignment of the EOI marker
			if ( bytepos >= 0 )
			{
				var fillbits:BitString = new BitString();
				fillbits.len = bytepos+1;
				fillbits.val = (1<<(bytepos+1))-1;
				writeBits(fillbits);
			}
			$FFD9 ,w |EOI
			return byteout;
		}
	}
;

|-------------------------------------------------
:main
	mark
	show clrscr

		'exit >esc<
		;


: main ;