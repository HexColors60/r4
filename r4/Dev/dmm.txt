| Dynamic Memory Management
| Based on http://www.bradrodriguez.com/papers/ms/pat4th-c.html
| Uses first fit.
| tag : 30 bits size + 1 bit last? block + 1 bit used? block
| each block is : [4 bytes tag]< size bytes of memory>[4 bytes tag]

^r4/lib/gui.txt
^r4/lib/btn.txt

#dmms | start of dmm space
#ptr #tag | used to keep information about current block
#size #walkptr 
#bx 0 #by 50 #h 20

| create tag value ( used? last? size -- )
| 8 bytes are taken from size for two tags
:settag! 2 << swap 1 << or or 'tag ! ;

:tag>last tag %10 and 1 >> ;
:tag>used tag %1 and ;
:tag>size tag 2 >> ;

| <tag><size bytes><tag>
:wtags! tag ptr 4 - ! tag ptr tag>size + ! ;

| init dmm system ( size -- )
:dmminit 0 1 pick2 settag!
	 mark
	 here 4 +
	 dup dup
	 'ptr ! 'dmms ! 4 + + 'here !
	 wtags! ;

:nextblock tag>size ptr + 8 + 'ptr ! ptr 4 - @ 'tag ! ;

| - PRINT ------------------------

:pblock here "HERE: %d" print cr
	dmms "DMMS: %d" print cr
	ptr "Block ptr: %d " print cr
	ptr 4 - @ "tag1: %d " print cr
	ptr ptr 4 - @ 2 >> + @ "tag2: %d " print cr
	tag>last tag>used "Used/Last: %d/%d" print cr
	tag>size "Size: %d bytes" print cr cr cr ;

:printdmm dmms 'ptr ! ptr 4 - @ 'tag !
:printdmmrec pblock tag>last 1 =? ( drop ; ) drop nextblock printdmmrec ;

| - DRAW ------------------------

| ( n -- ) draws a sequence of pixels left to right, top to bottom
:sequence dup bx + sw <=? ( drop dup h bx by vfill bx + 'bx ! ; )
	  sw - sw bx - sequence 0 'bx ! by h + 'by !
	  sequence drop ;

:adjust walkptr ptr =? ( oscuro ) drop ;
	  
:dtag gris adjust 4 sequence ;

:dmem tag>used 1? ( rojo )( verde ) drop adjust tag>size sequence ;

:dblock dtag dmem dtag blanco ;
	
:drawdmm dmms 'ptr ! ptr 4 - @ 'tag !
:drawdmmrec dblock tag>last 1 =? ( drop ; ) drop nextblock drawdmmrec ;

| -------------------------

| split ( size -- )
| splits an existing block into two
| 1st block: ptr=(bptr), tag=(used=1,last=0,size)
| 2st block: ptr=(bptr+size+8), tag=(0,btaglast,btagsize-size-8)
:split ptr tag
       over pick3 8 + + 'ptr !
       dup 0 swap %10 and 1 >> rot 2 >> pick4 - 8 - settag! wtags!
       'ptr !
       1 0 rot settag! wtags!
       ptr ;

| full (size -- )
| allocates full block
:full 1 tag>last rot settag! wtags! ptr ;

:allochere tag>size over - 16 >? ( drop split )( drop full ) ;
:trynext tag>last 1 =? ( 2drop -1 ; ) drop nextblock
:allocrec tag>used 1 =? ( drop trynext ; ) drop tag>size >? ( trynext ; ) allochere ;
:alloc dmms 'ptr ! dmms 4 - @ 'tag ! allocrec ;

| next block tag
:nextbtag ptr tag>size + 4 + @ ;
:prevbtag ptr 8 - @ ;

:rb dup 'ptr ! 4 - @ $FFFFFFFE and 'tag ! ;
:rnextb tag>last 0 =? ( drop nextbtag 1 and 0 =? ( drop 0 nextbtag dup %10 and 1 >> swap 2 >> tag>size + 8 + settag! )( drop ) )( drop ) ;
:rprevb ptr dmms <>? ( 8 - @ 1 and 0 =? ( drop 0 tag>last tag>size prevbtag 2 >> + 8 + settag! ptr prevbtag 2 >> - 8 - 'ptr ! )( drop ) )( drop ) ;

| releases block ( pointer -- )
:release rb rnextb rprevb wtags! ;
	 
:debug dup "%d" print cr cr ;

:f2i 0.5 + 1024.0 *. 16 >> ;

:tag 4 - @ ;
:lastbit %10 and 1 >> ;
:nextptr walkptr tag lastbit 1 =? ( drop ; ) drop walkptr dup tag 2 >> + 8 + 'walkptr ! ;
:prevptr walkptr dmms =? ( drop ; ) dup 8 - @ 2 >> - 8 - 'walkptr ! ;

:newalloc size f2i alloc 'walkptr ! cr ;

:newrelease walkptr -1 <>? ( release -1 'walkptr ! )( drop ) dmms 'walkptr ! ;

:*. 16 *>> ;

:go 10000 dmminit
    dmms 'walkptr !
    show clrscr
    blanco debug
    size f2i "Bytes to allocated: %d" print sp sp rojo 'newalloc "Alloc" btnt 
    verde 'nextptr "Next" btnt sp
    amarillo 'prevptr "Prev" btnt sp
    'nextptr >ri<
    'prevptr >le<
    azul 'newrelease "Release" btnt cr cr cr
    0.25 0.025 fdim
    -0.75 0.9 fpos
    azul 'size hslide cr cr cr cr cr cr cr cr cr
    1 'bx ! 50 'by ! drawdmm
    printdmm
    cminiflecha
    'exit >esc< ;

: 33 go ;
