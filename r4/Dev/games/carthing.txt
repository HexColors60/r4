| Very simple car physics
| from https://gamedev.stackexchange.com/questions/1796/vehicle-physics-with-skid
| Gamepad works in linux (behaves differently in windows..)
| (!) Crashes when the sprite is outside the screen

^r4/lib/gui.txt 
^r4/lib/bmr.txt 
^r4/lib/polygr.txt 
^inc/1492.bmr | contains the car sprite

#npos 0       | counter of all car positions
#hpos )( 800  | each car position is (x,y) = 2 * 4 bytes

#px #py | positionX, positionY - where the car is
#vx #vy | velocityX, velocityY - speed on each axis
#drag   | drag - how fast the car slows down
#angle  | angle - the rotation of the car
#av     | angularVelocity - speed the car is spinning
#ad     | angularDrag - how fast the car stops spinning
#power  | power - how fast car can accelerate
#ts     | turnSpeed - how fast to turn

| draws successive car positions
:drawpos npos 2 <? ( drop ; ) drop
	 'hpos npos 1- 100 mod 8 * + >r | draw from previous position
	 r @ r> 4 + @ op
	 2
:drawrec npos 99 min =? ( drop ; ) dup
	 npos swap - 100 + 100 mod 8 * 'hpos + >r
	 r @ r> 4 + @ line
	 1+ drawrec ;

| saves intermediate car positions	 
:savepos 'hpos npos 100 mod 8 * + >r
	 px 16 >> r !
	 py 16 >> r> 4 + !
	 npos 1+ 'npos ! ;
	 
:simulate px vx + 'px !
	  py vy + 'py !
	  vx drag *. 'vx !
	  vy drag *. 'vy !
	  angle av + 'angle !
	  av ad *. 'av !
	  power 0.0 =? ( drop 0.0 'av ! ; ) drop
	  savepos ;
	
:printstats px "px: %f " print cr
	   py "py: %f " print cr
	   vx "vx: %f " print cr
	   vy "vy: %f " print cr
	   drag "drag: %f " print cr
	   angle "angle: %f " print cr
	   av "angular velocity: %f " print cr
	   ad "angular drag : %f " print cr
	   power "power: %f" print cr cr
	   npos "NPOS: %d" print cr ;

:drawspeed px 16 >>
	   py 16 >>
	   px vx 10.0 *. + 16 >>
	   py vy 10.0 *. + 16 >>
	   3 glineg ;

| sprite is 64x104	   
:drawcar px 16 >> 32 -
	 py 16 >> 52 -
	 angle -1.0 *. 0.25 + 'auto bmr.drawr
	 amarillo drawspeed blanco ;

:draw printstats drawcar drawpos ;

:debug dup "%d" print cr ;

| gets the nth value from the mth joystick	
| ( nval numjoy -- # )
:joyval getjoy swap 4 * + @ ;
	
:joy0left 2 0 joyval 0? ( 1 )( 0 ) nip ;
:joy0right 2 0 joyval $FFFE =? ( 1 )( 0 ) nip ;
:joy0down 3 0 joyval $FFFE =? ( 1 )( 0 ) nip ;
:joy0up 3 0 joyval 0? ( 1 )( 0 ) nip ;

:joy0bval 8 0 joyval ;

| ( butn - 0/1 )
:joy0b? joy0bval 1 rot 1- << and 1? ( 1 )( 0 ) nip ;

:joy0b1 1 joy0b? ;
:joy0b2 2 joy0b? ;
:joy0b3 3 joy0b? ;
:joy0b4 4 joy0b? ;

:updatev angle dup cos power *. 'vx ! sin power *. 'vy ! ;

#maxpower 16.0

:accelerate power 0.1 + maxpower >? ( drop maxpower 'power ! )( 'power ! ) updatev ;
:brake power 0.2 - -? ( drop 0 'power ! )( 'power ! ) updatev ;
:slowdown power 0.05 - +? ( 'power ! )( drop 0.0 'power ! ) updatev ;

:speed joy0b1 1 =? ( drop accelerate ; ) drop 
       joy0b2 1 =? ( drop brake ; ) drop
       slowdown ;
       
| turn speed is a function of the power
| cannot turn if speed is zero
:adjpower power 2.0 /. *. ;

:goleft -0.0002 adjpower 'ts ! av ts + 'av ! 0.0 'ts ! ;
:tleft  joy0left  1 =? ( drop goleft ; ) drop ;

:goright 0.0002 adjpower 'ts ! av ts + 'av ! 0.0 'ts ! ;
:tright joy0right 1 =? ( drop goright ; ) drop ;
       
:inputs speed tleft tright ;

:go show clrscr debug
    inputs simulate draw
    'exit >esc< ;

:init 150.0 'px ! 150.0 'py !
      0.0 'vx ! 0.0 'vy !
      0.94 'drag !
      0.0 'angle !
      0.0 'av !
      0.94 'ad !
      4.0 'power !
      0.0 'ts ! ;
      
: init 33 go ;
